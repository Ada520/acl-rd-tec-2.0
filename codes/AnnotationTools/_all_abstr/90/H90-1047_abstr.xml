<?xml version="1.0" standalone="yes"?>

<Paper uid="H90-1047">
<Title>Syntactic and Semantic Knowledge in the DELPHI Unification Grammar</Title>
<Section position="1" start_page="0" end_page="231" type="abstr">
<SectionTitle>
Abstract
</SectionTitle>
<Paragraph position="0"> This paper presents recent natural language work on HARC, the BBN Spoken Language System. The HARC system incorporates the Byblos system \[6\] as its speech recognition component and the natural language system Delphi, which consists of a bottom-up parser paired with an integrated syntax/semantics unification grammar, a discourse module, and a database question-answering backend. The paper focuses on the syntactic and semantic analyses made in the grammar.</Paragraph>
<Paragraph position="1"> Introduction This paper discusses the unification-based grammar component of the BBN Delphi system, the natural language component of the BBN Spoken Language System. This grammar, previously discussed in \[4\]\[5\], is written in a variant of the Definite Clause Grammar formalism \[17\] and simultaneously assigns both syntactic structure and semantic interpretation to an utterance. The grammar comprises some 1300 rules (including those for terminal items), and has recently been evaluated on the ATIS air travel information domain with favorable results \[2\].</Paragraph>
<Paragraph position="2"> The paper has two main purposes. The first is to present this grammar's treatment of a number of syntactic and semantic phenonomena in the ATIS domain, in the belief that comparison of analyses are useful in and of themselves, particularly in the context of a common evaluation. In particular, we discuss the constraints imposed by subgrammars on conjunction, relaxation of subject verb agreement, optional argument subcategorization, and semantic interpretation of PPs and nominal compounds.</Paragraph>
<Paragraph position="3"> The second purpose is to argue for the necessity of a device which is frequently made use of Definite Clause Grammar work, but which has less often been utilized in the work on unification grammar that has appeared more recently (\[19\] \[14\]). This is the right-hand side &amp;quot;constraint relation&amp;quot; that does not derive any constituent of the utterance, but rather serves to constrain in various ways the feature assigments of those rule elements which do. Constraint relation elements are thus to be distinguished from other non-terminals which derive empty constituents, such as gaps or zero morphemes.</Paragraph>
<Paragraph position="4"> While constraint relations have long been used in DCG-based workto treat, among other things, problems of quantifier scoping and the interaction of quanfifer scope and anaphora \[16\] \[18\] we argue that there are other, more low-level issues of lexical semantics and syntax for which constraint relations are either conceptually useful or formally necessary, even in unification formalisms which allow full disjunction across features, such as \[10\] \[12\] \[11\] \[9\]. The remainder of the paper is divided into sections. In the next section, we first briefly review the formalism we use. In the two sections after that, we present syntactic analyses and semantic analyses made by the Delphi grammar, with emphasis placed on the use of constraint relation elements. Finally, in the last section we discuss the question of whether or not the constraint elements can be compiled out of grammar rules.</Paragraph>
<Paragraph position="5"> Grammar Formalism The Delphi grammar formalism is a variant of Definite Clause Grammar and is discussed in more detail in \[4\]\[5\].</Paragraph>
<Paragraph position="6"> Left- and right-hand side rule elements have a functor (their major category) and zero or more features in a fixed-arity, positional order. Features are slots which are filled by terms. Terms can either be variables, which are atoms prefixed by colons &amp;quot;:&amp;quot;, or functional terms consisting of a functor and zero or more features, again in fixed positional order, occupied by other terms. Note that this means that constants in Delphi are just nullary functions. Disjunctions of purely atomic values are allowed as terms, with the functor &amp;quot;:OR&amp;quot;. The following is an example role, much simplified for expository purposes, for handling NP conjunctions:</Paragraph>
<Paragraph position="8"> function will be discussed in the next section.</Paragraph>
<Paragraph position="9"> This formalism maintains the term unification practice of using functors with obligatory, positional arguments, rather than functorless feature structures with optional, labelled arguments, as in much recent work. There are several reasons for this. First of all, we find the functor very useful as a  way of indicating just what features are allowed in a given structure (and it is interesting to note attempts to restore it for just this purpose in \[13\].) Second, argument labels contribute their own clutter to the role. They would thus seem to be a notational win only if more than half the features of a given element are &amp;quot;don't-cares&amp;quot;. In our grammar, however, we find on average that only about 3% of the feature slots in rules are &amp;quot;don't-cares&amp;quot;.</Paragraph>
<Paragraph position="10"> We should emphasize, however, that none of the work presented here hinges on these notational choices, and all the points made in subsequent sections carry over just as well to other unification notations.</Paragraph>
<Section position="1" start_page="230" end_page="231" type="sub_section">
<SectionTitle>
Syntactic Constraint Analyses
</SectionTitle>
<Paragraph position="0"> Restrictions on agreement between features sometimes depend on the values of still other features. For example, English noun phrase conjunctions require that if one of the conjuncts belongs to a particular subgrammar (date, time etc.) then the other conjunct(s) must also belong to that subgrammar, but if neither of the conjuncts belongs to a subgrammar, there is no restriction. This can be done by including in the NP conjunction rule a constraint relation which provides a case-analyzing effect that could not be provided merely by unifying the variables ranging over the semantic type. This function is carried out by NPTYPE-FILTER, which we introduced above. This relation takes as its arguments the NPTYPE feature of the first conjunct, the NPTYPE of the second conjunct, and the NPTYPE feature of the conjunction as a whole. This relation, then, can be thought of as constraining the possible triples of these values. 1 We present four instances of this rule for illustration, where &amp;quot;~ 0&amp;quot; indicates production of the empty string.</Paragraph>
<Paragraph position="2"> The first two rules require that if either of the conjuncts of a conjoined NP belongs to the TIMENP or DATENP subgrammar, than the other conjunct must belong to that subgrammar, as well. The last two rules allow ordinary pronominal and non-pronominal NPs to conjoin freely. 2 In lAltematively, it can be viewed as computing a value for the NPTYPE feature of the conjunction from the values of the individual conjuncts. 2They also set the NPTYPE of the conjunction to being non-pronominal, since it cannot function as a pronoun.</Paragraph>
<Paragraph position="3"> this example, note that while the first two rules could be collapsed into a single rule utilizing unifying variables, the third and fourth cannot.</Paragraph>
<Paragraph position="4"> Another use of constraint relations is to &amp;quot;compute&amp;quot; a value from the feature values of the relevant consitutents, rather than requiring identity of features. For example, in NP conjunction with &amp;quot;and&amp;quot; in English, the person of the conjoined NP is first person if any of the conjuncts is first person, second person, if any of the conjuncts is second person and none is first person, and third person ff all the conjuncts are third person) This can be easily handled by the P-MIN constraint relation, which takes as its arguments the PERSON feature of the first conjunct, the PERSON of the second conjunct, and the PERSON feature of the conjunction as a whole. It has the following solutions:</Paragraph>
<Paragraph position="6"> Still another case in which constraint relations provide a kind of flexibility greater than that available using standard unification is to allow the grammar to express &amp;quot;degrees of grammaticality&amp;quot;. For example, in standard written English, it is common for a verb to agree in number with its subject. 4 What do the restrictions represent? What does restriction VU/1 mean? What do the transport codes AL and R mean? However, in spoken English, conjoined noun phrases sometimes appear with singular agreement on the verb.</Paragraph>
<Paragraph position="7"> What does RETURN ~ and RETURN MAX mean? What does class B and class Y mean? In still looser speech, agreement disappears even with non-conjoined subject noun phrases: List all the airlines that flies from Dallas to Boston nonstop. These facts can be handled by modifying the standard  and adding the following solutions for SUBJECT-VERB-AGREEMENT. This is a constraint relation that takes as its arguments the agreement feature of the sentence's sub-ject NP, the agreement feature of the sentence's VP, and the conjunction feature of the subject NP which indicates whether it is a conjunction or not.</Paragraph>
<Paragraph position="8">  The first of these solutions enforces standard subject verb agreement: whether the subject NP is a conjunction or not, the agreement features of the subject and the VP must be the same. The second allows the VP to bear the singular feature when the subject is plural, just in case the subject is a conjunction. The last two rules allow the subject and the VP to disagree, when the NP is not a conjunction. The statement about the conjunction status of the subject is necessary in these last two solutions to make them orthogonal to the first two, so that a single structure will not be unnecessarily analyzed with more than one solution.</Paragraph>
<Paragraph position="9"> This mechanism is superior to simply not requiring a VP to agree with its subject at all, by using distinct variables for the agreement features of the subject NP and the VP, since, given a large enough colpus, we can automatically associate different probabilities with the different solutions of this constraint relation. This is particularly useful in a spoken language system, since this will allow all the possibilities, with some degree of probability, but will always prefer the most common solution and will only choose a less likely solution if a more common one is unavailable.</Paragraph>
</Section>
<Section position="2" start_page="231" end_page="231" type="sub_section">
<SectionTitle>
Semantic Constraint Analyses
</SectionTitle>
<Paragraph position="0"> The facility for case analysis is also used in semantic interpretafion, where the meaning representation of constructions are computed in terms of values of certain features which cannot always be known in advance.</Paragraph>
</Section>
</Section>
</Paper>

