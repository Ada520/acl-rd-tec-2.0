<?xml version="1.0" standalone="yes"?>

<Paper uid="P79-1028">
<Title></Title>
<Section position="2" start_page="0" end_page="113" type="abstr">
<SectionTitle>
Abstract
</SectionTitle>
<Paragraph position="0"> It is our firm belief that solving problems in the domain of computational linguistics (CL) can provide a set of metaphors or powerful ideas which are of great importance to many fields. We have taught several experimental classes to students from high schools and universities and s major part of our work was centered around problems dealing with language.</Paragraph>
<Paragraph position="1"> We have set up an experimental Language Laboratory in which the students can explore existing computer programs, modify them, design new ones and implement them. The goal was that the student should gain a deeper understanding of language itself and that he/she should learn general and transferable problem solving skills.</Paragraph>
<Paragraph position="2"> exercise in pattern matching and symbol manipulation, where certain keywords trigger a few prestored answers. It may also serve as an example for how little machinery is necessary to create the illusion of understanding.</Paragraph>
<Paragraph position="3"> \[n our interdisciplinary research project (KLING eL el, 1977) we have tried to overcome these problems by providing opportunities for the student to explore powerful ideas in the context of non-trivial problems and by showing that the computer prescence can do much more for education than improve the delivery system for curricula established independently of it.</Paragraph>
<Paragraph position="4"> I. Introduction Problem solving with the computer for the non-computer expert is slowly recognized as an important activity in our educational system.</Paragraph>
<Paragraph position="5"> It is done best in a project-oriented course in which the student learns to solve problems in different domains. In the past, activities of this sort have been centered around numerical problems, physics problems and the standard computer science problems (eg like writing a sorting procedure).</Paragraph>
<Paragraph position="6"> 2. The state of the art The relevance of problems from linguistics has been ignored. The reasons for this fact are easy to explain: I) the educational community in the language-oriented fields has very little knowledge about using a computer to write interesting programs to gain a deeper understanding of the problems in their domain 2) the computer experts were not familiar with linguistics 3) the most commonly used programming lsnguegee end eyetemo ere inadequate to deal with the data structures and dialog requirements which are relevant for language processing 4) new fields like artificial intelligence, cognitive science end computational llnguletlee were not widely known The level of ignorance can best be seen by using ELIZA as an example: many people thought that it was a program which would &amp;quot;understand&amp;quot; the contents of a dialog. It was not evident to them that ELIZA represents nothing more than an ~. Coqnitive Science and Proqrammin~ In recent years the view has emerged that the language of computation is the proper dialect to describe basic issues in psychology, linguistics and education. Research in Cognitive Science has demonstrated that the phenomena surrounding computers are deep and obscure, requiring much experimentation.</Paragraph>
<Paragraph position="7"> Cognitive Science theories about problem solving, representation of knowledge and other cognitive abilitiesprovide the foundation for our understanding of programming.</Paragraph>
<Paragraph position="8"> We believe that the whole enterprise of programming can be much better explained with concepts from CL than with those from mathematics. Problems in CL are often ill-defined, algorithms are seldom given and programming is more a design task than it is s coding of a known algorithm. The problem formulation phase is more relevant than the execution of a Program and systems are needed to support this phase of the problem solving process. Successive formulation of programs serve aa stepping stones towards the goal of defining the specification of a problem.</Paragraph>
<Paragraph position="9"> Humane have a good intuitive understanding of the problems in CL and they can do the things (like communicate in natural language, deal with vast amounts of knowledge, infer new knowledge from exiting one) - even if they do not know how they do it. Programming can be understood as an effort to make our own knowledge explicit and can provide us with adequate metaphors to describe our own mental functions.</Paragraph>
<Paragraph position="10">  4. Oesiqn of a Lanquaqe Laboratory The design of learning environments is an important goal for the educational theorist and the teacher. The computer as a new technology has created almost unlimited possibilities to create new and challenging environments. The Turtle world (PAPERT 1979) and the simulation world of Smslltslk (KAY 1977) provide good models of what can be done.</Paragraph>
<Paragraph position="11"> In our project we have set up an experimental Language Laboratory in which the students can explore existing programs, modify them, dealgn new ones and implement them. We took great care in our design (by following the tradition of the LOGO projets as opposed to CAI approaches) that the students could work in an active mode end develop ideas in 8 personal way (not limited by the teachers approach). Our teaching style was not to provide answers but the learners were encouraged to use their own language knowledge to find e solution. Their work had to rely on self motivation which seems a more reasonable goal in CL where the products (eg poems, horoscopes, question/answering systems etc) can be more interesting and aesthetically pleasing then a set of numbers appearing as s result in numerical mathematics. With our Language Laboratory we wanted to create an environment in which the student's task is not to learn a set of formal rules (eg about the syntax of a programming language), but to give them s world in which they could develop sufficient inside into the way they used language to allow the transposition of this self-knowledge into programs.</Paragraph>
<Paragraph position="12"> The students were exposed to different formalisms (primarily to LOGO, but also to LISP, ATNs, semantic networks, MICRO-PLANNER) and could explore the range of possible models which could be implemented in a cognitively efficient way with these formalisms. We tried to engage them in problems of moderate complexity (the students ware no researchern working full-time in a project) and we crested micro-verslons of programs by ommltlng feoturea which were not essential for a conceptual understanding.</Paragraph>
<Paragraph position="13"> 5.~ P pw~rful ~dees There is little doubt that we will be unable to solve the problems of coverage in our school and university subjects and of predicting whet specific knowledge our students will need in thirty or forty years. Despite the fact that we would like to have more empirical evidence that problem solving skills can be taught, we have little choice, because we don't have any real alternative (for a detailed discussion of this issue, Bee SIMON 1978).</Paragraph>
<Paragraph position="14"> Cognitive Science and Artificial Intelligence have contributed to our understanding of problem solving processes and we believe that general problem solving skills, crystallized as powerful ideas, can be taught explicitly in the context of a rich environment of problems. The main goal of this paper is to show that CL provides this rich context (which if it is not superior than mathematics, st least complements mathematics).</Paragraph>
<Paragraph position="15"> Powerful ideas are nuggets of knowledge, which ere universally useful, which appear over and over in different disciplines and which can be connected In * natural and illuminating way with a large complex of other ideas.</Paragraph>
<Paragraph position="16"> One example of e powerful ides is the heuristic: &amp;quot;divide and conquer&amp;quot;. It appears to be an almost universal truth, but how it ia done in the context of a concrete problem situation is far from being trivial. Many of the typical problems (like writing a program to compute Factorial, to sort * set of objects or to solve e trivial puzzle) are too simple, so there ia llttle need to use this heuristic.</Paragraph>
<Paragraph position="17"> Furthermore many traditional programming systems are not build for (or do not even support) this problem solving approach, whereas in our work the heuristic took on a concrete meaning and was the only successful way to solve a problem.</Paragraph>
<Paragraph position="18"> In the following parts or this section we briefly describe a sat or powerful ideas which can be explored in the context of realistic problems and research areas in CL (the projects are fully described in BOECKER/FISCHER, 1978): 11 difference between syntax end semantic (eg in the context of writing a program to generate poetry, in solving word problems in algebra) 2) rule systems (s sort of production systems; they ere useful for the organisstion of programs to derive the plural form of an English noun given the singular, to conjugate French verbs, to characterize the rules and heuristics in a game or to implement the evaluation procedure of LISP) 31 design and Implementation of s mini-language (this silo.as us to describe s problem in terms which ere characteristic for the problem instead of being forced to use e given general purpose programming language; examples ere: production systems, pattern matcher, etc); in programming, it is a natural task to design your own representational system whereas in mathematics people mostly use the representational system given to them 4) experimentation with a wide variety of different grsmmewa (eg to generate and analyse algebraic expressions; to transform arabic  numerals into roman ones and vice versa; to explore transition networks and augmented transition networks in dealing with natural language) 5) knowledge representation: eg to derive implicit knowledge and to study the impact of processing at read-time (antecendent theorems) versus question-time (consequent theorems) in a system which dealt with family relations (a system of this sort can be contrasted with ELIZA or a program to cast horoscopes); the following diagram illustrates how ? implicit relationships (---) can be derived from 3 explicit ones within a family of four persons:</Paragraph>
<Paragraph position="20"> 6) exploration of statistical properties of languages in the context of s wide variety of different language games (eg like designing the distribution of a Scrabble game, information content of vowels in different languages etc) 7) general computational ideas (eg like backtracking, which is encounterd in parsing non-deterministc grammars and which could be applied to pattern matching and tree like data  structures) 6. Pattern Matchinq- an example for the.deslqn 9nd implementation of s minirlsnquaqe  A matching capability can be a key element for many problem solving tasks involving the computer to make otherwise large, complicated efforts reachable. The following powerful ideas can be investigated in the context of this project: I) incremental design: we can start with s pattern marcher which is basicly en EQUAL predicate. The next steps could be: a membership predicate, s pattern with slots of fixed size, s pattern with slots of arbitrary size (which creates the need for back-up), the possibilty for simultanous assignment of matched elements to pattern variables, the restriction of matching by using predicates etc Z) the problem is ill-defineds the specification of the pattern marcher should be derived from the needs of using it to simplify problem solving tasks. A partial implementation can be an important help for a further specification or for a revision of already existing parts, ie the problem formulation is an important part of the problem solving process 3) definition of a new language layer: the pattern matcher can be used as a new language layer between the problem and the programming language and it can help to reduce the distance between the two.</Paragraph>
<Paragraph position="21"> 4) glass-box approach: in many situations, we are primarily interested in using the pattern marcher. But by making use of an already existing program the student is not confined to a black box (like it would be in CAI environment); at any time he/she can look inside the program, open it up, change it to his/her own needs etc. A prerequisite for a program to be a glass-box is that it is implemented in a formalism the student is familiar with.</Paragraph>
<Paragraph position="22"> 5) recursive control structure, a pattern marcher is a good example for the power of recursive definitions and control structures which can be used in many other situations A pattern marcher can be used in all projects where symbolic structures have to be dissected and identified, eg for the translation from infix to prefix, for parsing and translating processes, for morphological analysis, for simple I/0 routines (eg the identification of keywords), for ELIZA like programs and for symbolic manipulation of algebraic expressions. We do not have the space to document the problem solving processes (including all the incomplete versions) which &amp;quot;occured in the context of implementing the pattern marcher (see BOECKER/FISCHER 1978) but we want to give examples of its use. The simplification with the help of a pattern marcher can be demonstrated by a program for infix to prefix translation (written in LOGO! the program also nicely shows the power of recursive  A ~l~E~ ~o~r ~ ~o~ c A This version of the program can be extended easily to include other operators like &amp;quot;&gt;&amp;quot; or &amp;quot;&lt;&amp;quot; : ~ (S~'I~C@ &amp;quot;~'l&amp;quot;~ ~ :~ R~I~ :~)</Paragraph>
</Section>
</Paper>

