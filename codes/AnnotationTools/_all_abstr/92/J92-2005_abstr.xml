<?xml version="1.0" standalone="yes"?>

<Paper uid="J92-2005">
<Title>Incremental Processing and the Hierarchical Lexicon</Title>
<Section position="2" start_page="0" end_page="224" type="abstr">
<SectionTitle>
1. Introduction
</SectionTitle>
<Paragraph position="0"> The main reasons mentioned for the considerable attention paid to hierarchical lexicon structures are the fact that redundancy in the lexicon is avoided, and that structuring the lexicon facilitates the development of large and complex lexicons. No attention has, however, been paid to the role the hierarchical lexicon could play in natural language processing. Categorial Grammar (CG) has an interest in efficient and psychologically plausible, at least incremental, processing. Although CG is a radically lexicalist grammatical theory, little attention has been paid to the structure of the lexicon. The aim of the present article is to bring CG, the hierarchical lexicon, and incremental processing together, to investigate the role of the hierarchical lexicon during incremental parsing with categorial grammars. The rules and derivations of a categorial grammar do not describe syntactic structures, but represent the proceedings of the parser while constructing a semantic representation of a sentence. This property of CG is referred to as representational nonautonomy (Crain and Steedman 1982). It will be shown that especially in the case of ambiguity, the combination of a hierarchical lexicon structure and representational nonautonomy provides efficient ways of dealing with ambiguities: within a proof-theoretic approach to CG, rules that allow the parser to reason about the structure of the lexicon are presented. Two parsing techniques are presented.</Paragraph>
<Paragraph position="1"> Windowing is a technique for incrementally accessing the hierarchical lexicon. While incrementally parsing the sentence, the parser commits itself to lexical information it can commit to, leaving other choices implicit in the hierarchical lexical structure of the elements in the input. Lexical preferencing implements preferences in the parsing process as a natural consequence of the hierarchical structure of the lexicon: information lower on in the hierarchical lexicon is preferred over more general information.</Paragraph>
<Paragraph position="2"> Idiomatic expressions are presented as an example of these preferences: an idiomatic expression is preferably interpreted as such, and not in the nonidiomatic interpretation of which the head of the idiom is a part.</Paragraph>
<Paragraph position="3"> * Institute for Language Technology and AI (ITK), PO Box 90153, 5000 LE Tilburg, the Netherlands. E-marl: vdlinden@kub.nl (D 1992 Association for Computational Linguistics Computational Linguistics Volume 18, Number 2 In Section 2 the proof-theoretic approach to CG is presented. Next, in Section 3 a hierarchical lexicon structure for CG is presented. Two category-forming connectives that make the structure of the lexicon visible for the parser are introduced. Windowing is discussed in Section 4. In Section 5 parsing preferences are discussed in general, and preferences for the interpretation of idioms are discussed in particular.</Paragraph>
<Paragraph position="4"> 2. Categorial Grammar and Proof Theory</Paragraph>
<Section position="1" start_page="0" end_page="220" type="sub_section">
<SectionTitle>
2.1 The Lambek Calculus
</SectionTitle>
<Paragraph position="0"> Recently, proof theory has aroused the interest of categorial grammarians. In the Lambek calculus (L-calculus, L; Lambek 1958), the most salient example of the application of proof theory to categorial grammar, the rules of the grammar become a set of axioms and inference rules. Together, these form a logical calculus in which parsing of a syntagm is an attempt to prove that it follows as a theorem from the set of axioms and inference rules. Following the work of Van Benthem (1986) and Moortgat (1988; 1987) the Lambek calculus has become popular among a number of linguists (Barry and Morrill 1990; Hendriks 1987).</Paragraph>
<Paragraph position="1"> Categories in CG can either be basic (np, s, n) or complex. A complex category consists of a binary category forming connective and two categories, for instance, np\s. In the product-free L-calculus the set of connectives (also called type constructors) is {\,/}. A complex category is a functor, an incomplete expression that forms a result category if an argument category is found. Throughout this paper the Lambek notation, in which the argument category is found under the slash, is applied. Consider for example the categorial representation of an intransitive verb: np\s looks for an np to its left and results in an s.</Paragraph>
<Paragraph position="2"> The elements the calculus operates upon are categories with semantic and prosodic information added, denoted with &lt;syntax, prosody, semantics&gt;, and referred to as signs. Information not relevant for the discussion is omitted. In the version of L used here, complex syntactic categories take signs as their arguments. Semantics is represented with formulas of the lambda-calculus. Prosodic information merely consists of a prosodic bracketing; for instance, the string john sleeps is denoted as john + sleeps, where + is a noncommutative, nonassociative concatenation operator. Concatenation of some C/~ with the empty prosodic element c results in 4.</Paragraph>
<Paragraph position="3"> The L-calculus extends the power of categorial grammar basically because it adds so-called introduction rules to the proof-theoretic complements of categorial reduction rules, elimination rules. For each category-forming connective, introduction and elimination rules can be formulated. With respect to semantics, elimination corresponds to functional application and introduction to lambda abstraction. Various approaches have been proposed for deduction in L. In its standard representation the L-calculus is a sequent calculus. More recently, natural deduction has been applied to the calculus (Barry and Morrill 1990), as well as proof procedures from linear logic (Roorda 1990). 1 Throughout this article the sequent format is used.</Paragraph>
<Paragraph position="4"> In definition (1), W and X are categories, Y and Z are signs, and P, T, Q, U and V are sequences of signs, where P, T, and Q are nonempty. A sequent in L represents a derivability relation, =~, between a nonempty finite sequence of signs, the antecedent, and a sign, the succedent. A sequent states that the string denoted by the antecedent is in the set of strings denoted by the succedent. The axioms and inference rules of the calculus define the theorems of the calculus with respect to this derivability relation.</Paragraph>
<Paragraph position="5">  Erik-Jan van der Linden Incremental Processing and the Hierarchical Lexicon Recursive application of the inference rules on a sequent may result in the derivation of a sequent as a theorem of the calculus. In definition (1) the calculus is presented. The elimination of a type constructor is denoted by E; introduction by I.</Paragraph>
<Paragraph position="6"> Definition 1 (Lambek, sequent calculus)</Paragraph>
<Paragraph position="8"> The uppersequent of an inference rule is a theorem of the calculus if all of its subsequents are theorems. In Example 1 a sentence containing a transitive verb is parsed by proving that it reduces to s. To the sequence of lexical signs associated with the strings in the input, the inference rules are recursively applied until all leaves of the proof tree are axioms. The derivation results in the instantiation of the semantics of the sentence.</Paragraph>
<Paragraph position="9"> Example 1 (np,john,john) ((np\ s)/np,loves,loves) (np,mary, mary} ::~ (s,john+loves+mary, loves(mary)(john)) if {np, mary, mary) =~ {np,mary, mary)</Paragraph>
<Paragraph position="11"></Paragraph>
</Section>
<Section position="2" start_page="220" end_page="221" type="sub_section">
<SectionTitle>
2.2 Other Connectives
</SectionTitle>
<Paragraph position="0"> The product-free version of the Lambek calculus includes two connectives, / and \. On the basis of these connectives and the inference rules of the L-calculus, a range of linguistic constructions and generalizations remain for which no linguistically adequate accounts can be presented. In order to overcome this problem, new category-forming connectives have been proposed (as a lexical alternative of the specialized rules of for instance CCG \[Steedman 1987\]). An example is the connective T for unbounded dependencies (Moortgat 1988). XTY denotes a category X that has an argument of category Y missing somewhere within X. The constituent John put on the table in what John put on the table has as its syntactic category s T np. To what the category s/(s Tnp) is assigned, which takes the incomplete clause as its argument.</Paragraph>
<Paragraph position="1"> The A-connective (Morrill 1990) is one of a set of boolean connectives that can be used to denote that a certain lexical item can occur in different categories: square can be n/n and n, and is therefore assigned the category (n/n) An. The ?-connective (ibid.) is used to denote optionality, for instance in the case of belief: n/(sp?), which accounts for belief in the belief and the belief that Mary lives.</Paragraph>
<Paragraph position="2"> These connectives are introduced to enable the inference engine behind the calculus to deal with lexical ambiguities and to 'reason' about lexical items. This is in line  Computational Linguistics Volume 18, Number 2 with the principle of representational nonautonomy, which states that syntactic rules describe what the processor does while assembling a semantic representation.</Paragraph>
<Paragraph position="3"> 3. Inheritance and the Hierarchical Lexicon To allow the inference engine to reason about lexical structures in which inheritance relations are present, the calculus should be extended, and a more sophisticated structure should be assigned to the categorial lexicon than the list or bag that is usually considered in CG (with the exception of Bouma 1990). The current section deals with the lexicon; the next sections deal with the extension of the calculus.</Paragraph>
</Section>
<Section position="3" start_page="221" end_page="223" type="sub_section">
<SectionTitle>
3.1 An Example: Idioms
</SectionTitle>
<Paragraph position="0"> An idiomatic expression and its verbal head can be said to maintain a lexical inheritance relation: an idiomatic expression inherits part of its properties from its head.</Paragraph>
<Paragraph position="1"> Here, syntactic category, syntactic behavior, morphology, and semantics are discussed briefly.</Paragraph>
<Paragraph position="2">  ment-structures 2 and have the same format as the verbs that are their heads. It is therefore possible to relate the syntactic category of the idiom to that of its head (see also Zernik and Dyer 1987). The verb itself does not specify prosodic information for the argument and the idiom is a specialization of the verb because it does specify prosodic information. In other words, the verb (kick) subcategorizes for the whole set of strings with category np, whereas the idiom subcategorizes for the subset of that set (the + bucket). The information that the object argument is specified for a certain string can thus be added monotonically. Inheritance relations between lexical items are denoted here with a category-forming connective ~-. Mother ~- Daughter states that Daughter is a specialization of Mother. The relation between verb and idiom is part of the lexical structure which is associated with the lexical entry of the verb. KICK, KICK_TV and KICK_THE_BUCKET are represented as in Example 2.</Paragraph>
<Paragraph position="3"> Example 2  a. KICK: (KICK_TV ~- KICK_THE_BUCKET, kick) b. KICK_TV: ((np\s)/(np,_),_) c. KICK_THE_BUCKET: (_/(_, the + bucket), _) 3.1.2 Morphological Properties. The verb that is the head of an idiomatic expression has the same inflectional paradigm as the verb outside the expression: for instance, if a verb is strong outside an idiom, it is strong within the idiom.</Paragraph>
<Paragraph position="4"> 3.1.3 Syntactic Behavior. The syntactic behavior of idioms should partly be explained  in terms of properties of their heads. For example, it is not possible to form a passive on the basis of predicative and copulative verbs, either inside or outside an idiomatic expression. 3 This information is inherited by the idiom from its verbal head.  Erik-Jan van der Linden Incremental Processing and the Hierarchical Lexicon 3.1.4 Semantics. The traditional definition of an idiom states that its meaning is not a function of the meanings of its parts and the way these are syntactically combined; that is, an idiom is a noncompositional expression. Under this definition, their meaning can be subject to any other principle that describes in what way the meaning of an expression should be derived (contextuality, meaning postulates...). A definition that states what the meaning is, is preferable: the meaning of an idiom is exclusively a property of the whole expression. 4 The meaning of the idiom cannot be inherited from the verb that is its head, but should be added nonmonotonically.</Paragraph>
<Paragraph position="5"> Example 3  a. KICK: (KICK_TV ~- KICK_THE_BUCKET, kick, AxAykick(x)(y)) b. KICK_TV: ((np\s)/np,_,_} c. KICK_THE_BUCKET: (_/(_, the + bucket, _), _, &amp;x&amp;ydie(y) ) 3.1.5 Inheritance. The full specification of a sign is derived by means of an operation similar to priority union (Kaplan 1987, p. 180) or default unification (Bouma 1990), denoted by n. N is defined as a function from pairs of mother and daughter signs to  fully specified daughter signs and runs as follows. If unification, U, is successful for the values of a certain property of mother and daughter, the result of n for that value is the result of U, where unification is understood in its most basic sense: variables unify with constants and variables; constants unify with variables and with constants with an equal value (prosodic information in Example 4). If the values do not unify, the value of the daughter is returned (semantic information in Example 4).</Paragraph>
<Paragraph position="7"> The inheritance networks for which N is defined are unipolar, nonmonotonic, and homogeneous (Touretzky, Horty, and Thomason 1987). For other networks, other reasoning mechanisms are necessary to determine the properties of a node (Touretzky, Horty, and Thomason 1987; Touretzky 1986; Veltman 1990). 5 More specific information thus takes precedence over more general information.</Paragraph>
<Paragraph position="8"> This is a common feature of inheritance systems, and is an application of 'proper inclusion precedence,' which is acknowledged in knowledge representation and (computational) linguistics (De Smedt 1990; Daelemans 1987; other papers in this special issue).</Paragraph>
<Paragraph position="9"> There exists a clear relation between this principle and the linguistic notion blocking. Blocking is &amp;quot;the nonoccurrence of one form due to the simple existence of another&amp;quot; (Aronoff 1976, p. 41). For instance, the nominal derivation *graciosity of gracious is blocked by the existence of grace. Daelemans (1987) and De Smedt (1990) show that in a hierarchical lexicon structure, blocking is equivalent to the prevalence of more specific information over more general information. For instance, the more general principle in the example is that a nominal derivation of some abstract adjectives equals stem + ity, and the more specific information is that in the case of gracious the nominal derivation is grace. In the hierarchical lexicon, the principle of priority to the instance  Computational Linguistics Volume 18, Number 2 also blocks ?graciousness (whereas this is not the case for Aronoff's model). In Dutch, the participle ~geslaapt that has been formed on the basis of regular morphological processes is blocked because the past participle of slapen is geslapen.</Paragraph>
</Section>
<Section position="4" start_page="223" end_page="224" type="sub_section">
<SectionTitle>
3.2 Other Lexical Relations
</SectionTitle>
<Paragraph position="0"> Verbs that can be either transitive or intransitive, such as kick, can in principle be modeled with the use of the A-connective: Inp\s~ ~y3xkick(x)(Y) I /~ I (np\s) /nP~ ~x,~ykick(x)(Y) I.</Paragraph>
<Paragraph position="1"> There are, however, two generalizations missing here. Firstly, the transitive and the intransitive form share the syntactic information that their reducible category is s and their subject argument is np. Secondly, the denotation of the transitive subsumes the denotation of the intransitive: the semantics of the transitive verb is more specific than the semantic representation of the intransitive. The use of the optionality operator ? (((np\s)/?np)) would imply that kick is in principle an intransitive verb, that has one optional argument, whereas in fact the reverse is true: kick is a two-placefunctor of which one argument may be left unspecified syntactically. The transitive and intransitive verb can be said to share their semantic value, but in the case of the intransitive, the syntactically unspecified object is not bound by a h-operator but by an (informationally richer) existential quantor. The transition from the transitive to the intransitive is represented as a lexical type-transition (Dowty 1979, p. 308).</Paragraph>
<Paragraph position="2"> Definition 2 (detransitivization) detrans : y xD(x)(y) From a syntactic point of view, the transitive form of the verb can be said to inherit the syntactic information from the intransitive and to add a syntactic argument. From a semantic point of view, the transitive inherits the semantic information that is specified for the KICK entry as a whole. The intransitive inherits the same information and stipulates application of detransitivization to it. The lexical relation between the transitive and the intransitive is thus different from that between a verb and an idiom: in the case of the idiom a syntactic argument is further instantiated whereas here a syntactic argument is added. To represent this distinction, a different connective is used: &gt;&gt;. With the use of this type constructor, the intransitive and the transitive can be placed in an inheritance relation (as seen in Example 5). &gt;&gt; is a category forming connective which takes two signs to form a category.</Paragraph>
<Paragraph position="3"> Example 5  a. KICK: IKICKdV ~ KICK_TV~ kick~ ,~x~ykick(x)(y)l c. KICK_IV: Inp\s, _, detrans(KICK)~ b. KICK_TV: Isynt(KICKdV)/np~_~sem(KICK)~  The lexical structure presented here can be considered equal to that presented by Flickinger (1987) and Pollard and Sag (1987) for HPSG. They present a hierarchy in which not only transitive and intransitive verbs, but other classes of verbs are represented as well. A minor difference is that Flickinger and Pollard and Sag place classes of verbs in hierarchical relations, whereas here individual verbs maintain inheritance  Erik-Jan van der Linden Incremental Processing and the Hierarchical Lexicon relations. The main difference with this and other previous approaches is that with the introduction of connectives for inheritance relations, inference rules for these connectives can be presented that describe the legal moves of the inference engine when reasoning about these lexical structures. This will be discussed in the next section.</Paragraph>
</Section>
</Section>
</Paper>

