<?xml version="1.0" standalone="yes"?>

<Paper uid="J92-2002">
<Title>Inheritance and Constraint-Based Grammar Formalisms R6mi Zajac*t Project POLYGLOSS</Title>
<Section position="2" start_page="0" end_page="160" type="abstr">
<SectionTitle>
1. Introduction
</SectionTitle>
<Paragraph position="0"> Ideally, a linguistic formalism combining the best of the object-oriented approach and the unification-based approach would be realized in a constraint-based architecture for an object-oriented language based on inheritance, feature structures, and unification.</Paragraph>
<Paragraph position="1"> The Typed Feature Structure language (TFS) is an attempt to provide a synthesis of several key concepts stemming from unification-based grammar formalisms (feature structure: Kay 1984) knowledge representation languages (inheritance), and logic programming (narrowing). The formalism supports an object-oriented style based on abstraction and generalization through inheritance; it is a fully declarative formalism based on unification of typed feature structures. It is flexible and has enough expressive power to support various kinds of linguistic theories, not necessarily based on constituencyL The use of an object-oriented methodology for natural language processing is very attractive, and the use of inheritance offers a number of advantages such as abstraction and generalization, information sharing and default reasoning, and modularity and reusability (Daelemans 1990). Inheritance-based descriptions are already used in computational linguistics: linguistic theories such as Systemic Functional Grammar (Halliday 1985), Word Grammar (Fraser and Hudson 1990), or HPSG (Pollard  the only linguistic theory based on both inheritance and feature structures.</Paragraph>
<Paragraph position="2"> (~ 1992 Association for Computational Linguistics Computational Linguistics Volume 18, Number 2 and Sag 1987) make use of inheritance to describe linguistic structures at the lexical, morphological, syntactic, or semantic (conceptual) levels. These theories are usually directly implemented in object-oriented programming languages (e.g., LOOM in the case of the PENMAN system \[Mann and Matthiessen 1985\]), but there is a growing number of linguistic formalisms used for specific purposes, e.g., DATR (Evans and Gazdar 1989) for the lexicon.</Paragraph>
<Paragraph position="3"> On the other hand, current linguistic theories such as LFG, UCG, HPSG, and some formalisms for linguistic description such as FUG or PATR-II are based on the notion of partial information: linguistic structures are described using feature structures that give partial information about the object being modeled, a linguistic structure being described by a set of feature structures that mutually constrain the description. Feature structures are partially ordered according to a subsumption ordering interpreted as an ordering on the amount of conveyed information; the combination of information is defined as the unification of feature structures. Formalisms based on feature structure and unification are declarative, and they can be given a sound formal semantics.</Paragraph>
<Paragraph position="4"> Combining object-oriented approaches to linguistic description with unification-based grammar formalisms, as in HPSG, is very attractive. On one hand, we gain the advantages of the object-oriented approach: abstraction and generalization through the use of inheritance. On the other hand, we gain a fully declarative framework, with all the advantages of logical formalisms: expressive power, simplicity, and sound formal semantics. To arrive at such a result, we have to enrich the formalism of feature structures with the notion of inheritance and abandon some of the procedural features of object-oriented languages in order to gain referential transparency.</Paragraph>
<Paragraph position="5"> Referential transparency is one of the characteristic properties of declarative languages (Stoy 1977), where the meaning of each language construct is given by a few simple and general rules. For example, the value of a variable should be independent from its position within the scope of its declaration. This is true for PROLOG variables inside a clause, but not for PASCAL or LIsP variables that make use of assignment. A higher level example is the meaning of a procedure: it is not transparent if the procedure makes use of global variables that are set by some other procedure. Similarly, the meaning of a PROLOG predicate should be transparent because there is no global variable, but a predicate definition might be modified during execution by imperative predicates such as assert and retract, thus destroying the referential transparency of pure PROLOG.</Paragraph>
<Paragraph position="6"> Clearly, most of the object-oriented languages lack referential transparency in several ways, using for example procedural attachments for object methods. Another example is the use of nonmonotonic inheritance, which is advocated in computational linguistics by, for example, Evans and Gazdar 1989; Bouma 1990; De Smedt and de Graaf 1990; and Fraser and Hudson 1990. Nonmonotonic inheritance is seen as a practical device designed to deal with exceptions, but such a feature goes against generality and referential transparency. Furthermore, as expressed by Etherington et al. 1989, a still unresolved issue in nonmonotonic reasoning is the issue of ... scaling formal non-monotonic theories up to real problems (merely a formality?). Most existant theories are intractable some don't have even a proof theory--and it is often difficult to tell how large bodies of information will (or even should) interact.</Paragraph>
<Paragraph position="7"> Given the complexity of the state of the art in nonmonotonic reasoning and the lack of  R6mi Zajac Inheritance and Constraint-Based Grammar Formalisms a basic commonly agreed formalization, a the issue of nonmonotonicity is not addressed in the work described in this article.</Paragraph>
<Paragraph position="8"> Knowledge representation languages are evolving toward more declarativity, as exemplified by the evolution from KL-ONE (Brachman and Schmolze 1985) to languages such as GLASSIC (Borgida et al. 1989) or LOOM (MacGregor 1988, 1990). The terminological component describing the objects (the data model of object-oriented database systems) has always been more declarative than the assertional component (procedural attachment or methods), and the current trend is to integrate those two components more closely, where the assertional component is some kind of rule-based system, as in LOOM (Yen, Neches, and MacGregor 1988).</Paragraph>
<Paragraph position="9"> Typed feature structures are very similar to structured objects of object-oriented languages and to conceptual structures of knowledge representation languages. Thus, typed feature structures have the potential to act as a lingua franca for both computational linguistics and artificial intelligence, and this should ease the communication between those two worlds. Since conceptual structures are used for example in text generation (Bourbeau et al. 1990) or knowledge-based machine translation (Nirenburg et al. 1992), typed feature structures provide an attractive alternative to current procedural implementations.</Paragraph>
<Paragraph position="10"> In Section 2, we present a language that combines the notions of partial information and inheritance in a fully declarative framework. It is based on feature structures augmented with the notion of types, which are organized into an inheritance network.</Paragraph>
<Paragraph position="11"> Using types, it is possible to define structured domains of feature structures and to classify feature structures. Logical conditions are attached to types, akin to method attachment, but in a fully declarative framework. Recursivity is an integral part of the language, giving the necessary expressive power for describing complex recursive linguistic structures. We end the section by an overview of the TFS abstract rewrite machine used for computing descriptions of the meaning of typed feature structures. 3 Section 3 describes the use of inheritance in two examples of unification grammars using the TFS formalism: an HPSG grammar for a fragment of English and an LFG-style transfer grammar for a small machine translation problem between English and French.</Paragraph>
</Section>
</Paper>

