<?xml version="1.0" standalone="yes"?>

<Paper uid="P85-1014">
<Title>New Approaches to Parsing Conjunctions Using Prolog</Title>
<Section position="1" start_page="0" end_page="122" type="abstr">
<SectionTitle>
Abstract
</SectionTitle>
<Paragraph position="0"> Conjunctions are particularly difficult to parse in traditional, phra.se-based gramniars. This paper shows how a different representation, not b.xsed on tree structures, markedly improves the parsing problem for conjunctions.</Paragraph>
<Paragraph position="1"> It modifies the union of phra.se marker model proposed by GoodalI \[19811, where conjllnction is considered as tile linearization of a three-dimensional union of a non-tree I),'med phrase marker representation. A PItOLOG grantm~tr for conjunctions using this new approach is given. It is far simpler and more transparent than a recent phr~e-b~qed extraposition parser conjunctions by Dahl and McCord \[1984\].</Paragraph>
<Paragraph position="2"> Unlike the Dahl and McCor, I or ATN SYSCONJ appr~ach, no special trail machinery i.~ needed for conjunction, beyond that required for analyzing simple sentences. While oi contparable C/tficiency, the new ~tpproach unifies under a single analysis a host of related constructions: respectively sentences, right node raising, or gapping. Another ,'ulvanrage is that it is also completely reversible (without cuts), and therefore can be used to generate sentences.</Paragraph>
<Paragraph position="3"> John and Mary went to tile pictures Ylimplc constituent coordhmtion Tile fox and tile hound lived in tile fox hole and kennel respectively CotJstit,wnt coordination &amp;quot;vith r.he 'resp~ctively' reading John and I like to program in Prolog and Hope Simple constitmvR co~rdinatiou but c,~, have a collective or n.sp,~'tively reading John likes but I hate bananas ~)tl-c,mstitf~ent coordin,~tion Bill designs cars and Jack aeroplanes Gapping with 'resp,~ctively' reading The fox. the honnd and the horse all went to market Multiple c,mjunets *John sang loudly and a carol Violatiofl of coordination of likes *Wire (lid Peter see and tile car? V/o/atio/i of roisrdJ)l=lte strC//C/'trlz'e constr.~int *1 will catch Peter and John might the car Gapping, hut componcztt ~cnlenccs c.ntain unlike auxiliary verbs ?Tire president left before noon and at 2. Gorbachev Introduction The problem addressed in this paper ~s to construct ,~ gr;unmatical device for lumdling cooL dination in natural language that is well founded in lingui.~tic theory and yet computationally attractive. 'the linguistic theory, should be powerful enough to describe ,~ll of the l)henomenon in coordi:tation, hut also constrained enough to reject all u.'lgr;unmatical examples without undue complications. It is difficult to ;tcldeve such ;t line h;dancc - cspcci,dly since the term grammatical itself is hil,hly subjccl.ive. Some examples of the kinds of phenolr-enon th:tt must l)e h;mdh.d are sh.,'.wl hi fig. t '\['he theory shouhl Mso be .~menable to computer hnpien:ellt~tion. For example, tilt represeuli~tion of the phrase, marker should be ,'onducive to Imth C/le~u! process description antl efficient implementation of the associated operations as defined iu the linguistic theory.</Paragraph>
<Paragraph position="4">  The goal of the computer implementation is to prod,ce a device that can both generate surface sentences given ;t phrase inarker representation and derive a phrase marker represcnt;Ltion given a surface sentences. Thc huplementalion should bc ~ efficient as possible whilst preserving the essential properties of the linguistic theory. We will present an ir, ph:n,cut,'ttion which is transparent to the grammax and pcrliaps clemler &amp; more nmdular than other systems such ,~ the int,:rpreter for the Modilh:r Structure Cram,,,ar.~ (MSG.,) of l)alll &amp; McCord \[1983 I.</Paragraph>
<Paragraph position="5"> &amp;quot;\]'lie NISG systenl will be compared with ~ shnpliGed irnl)lenlenl.;~tion of tile proposed device. A table showin K tile execution thne of both systems for some sample sen- null tences will be presented. Furthermore, the ,'ulvantages and disadvantages of our device will be discussed in relation to the MSG implementation.</Paragraph>
<Paragraph position="6"> Finally we can show how the simplifled device can l)e extended to deal with the issues of extending the system to handle nmltiple conjuncts ~d strengthening the constraints of the system.</Paragraph>
<Paragraph position="7"> This representation of a phrase marker is equivalent to a proper subset of the more common syaxtactic tree representation. This means that some trees may not be representable by an RPM and all RPMs may be re-cast as trees. (For exmnple, trees wit.h shared nodes representing overlapping constituents are not allowed.) An example of a valid RPM is given in fig. 3 :-The RPM Representation The phrase marker representation used by the theory described in the next section is essentially that of the Reduced Phrase Marker (RPM) of L,'mnik &amp; Kupin \[1977\]. A reduced phrase maxker c,'m be thought of im a set consist- &amp;quot; ing of monostrings ,'rod a termiual striltg satisfying certain predicates. More formally, we haws (fig. 2) :-Sentence: Alice saw 13ill RPM representation: {S. Alice.saw.Bill. NP.saw.Bill. Alice.V.Bill.</Paragraph>
<Paragraph position="8"> Alice.VP.Alice.saw.NP} Fig 3: Aa example of RPM representation Let E and N denote the set of terminals and non-terminals respectively.</Paragraph>
<Paragraph position="9"> Let ~o,~, x E: (TI. U N)'.</Paragraph>
<Paragraph position="10"> Let z, y, z E Z'.</Paragraph>
<Paragraph position="11"> Let A be a single non-terminal.</Paragraph>
<Paragraph position="12"> Let P be an arbitrary set.</Paragraph>
<Paragraph position="13"> Then ~o is a monostrmg w.r.t. ~ &amp; N if ~o E Z'.N.E'.</Paragraph>
<Paragraph position="14"> Suppose~o = zAz and that ~o,$6:P where P is a some set of strings. We can also define the following predicates :yisa*~oin PifxyzEP dominates ~b in P if ~b = zXy. X # 0 and x#A.</Paragraph>
<Paragraph position="15"> W precedes v) in P if 3y s.t. y isa* ~o in P.</Paragraph>
<Paragraph position="17"> dominates ~o in P or ~o dominates ~b in P or ~b precedes ~ in P or ~,, precedes ~b in P.</Paragraph>
<Paragraph position="18">  This RPM representation forms the basis of i, he linguistic theory described in the next section. The set representation ha.s some dcsir;d~M advantages over a tree representation in terms of b.th simplicity of description and implementation of the operations.</Paragraph>
<Paragraph position="19"> Goodall's Theory of Coordination Goodall's idea in his draft thesis \[Goodall??\] wa.s to ext,md the definition of I.a.snik ~md t(upin's RPM to cover coordiuation. The main idea behind this theory is to apply tilt. notion that coordination remdts from *he union of phr,~e markers to the reduced I)hrmse marker. Since R PMs axe sets, this h,'m the desirable property that the union of RI'Ms wouhl just be the falltiliar set union operation. For a computer intplemeutation, the set union operation can be realized inexpensively. In contr,-Lst, the corresponding operation for trees would necessitate a much less simple and efficient union operation than set union.</Paragraph>
<Paragraph position="20"> However, the original definition of the R.PM did not ~nvisage the union operation necessary for coordination. &amp;quot;\['he RPM w~ used to represent 2-dimensional structure only. But under set union the RPM becomes a representation of 3-dimensional structure. The admissibility predicates dominates zmd precedes delined on a set of monustrings with a single non-terminal string were inadequate to describe 3-dimensional structure.</Paragraph>
<Paragraph position="21"> B;~ically, Goodall's original idea w~ to extend the dominates ~m(l precedes predicates to handle RPMs under the set union operation. This resulted in the relations e-dominates ,'rod e-precedes ,xs shown in fig. 4 :-Assuming the definitions of fig. 2 and in addition let ~, f2, 0 E (~ O N)&amp;quot; and q, r, s, t, u E \]~', then ~o e-dominates xb in P if ~ dominates ~b I in P. X=w = ~'. e~/fl = Xb and = -- g in P.</Paragraph>
<Paragraph position="22"> ~o e-precedes Xb in P if y lea* ~o in P. v lea* in P. qgr -~ s,~t in P. y ~ qgr and u ~ ~t where the relation - (terminal equiralence) is  This extended definition, in particular - the notion of equivalence forms the baals of the computational device described in the next section, llowever since the size of&amp;quot; the RPM may be large, a direct implementation of the above definition of equivMence is not computationMly fe,'tsible. In the actual system, an optimized but equivalent alternative definition is used.</Paragraph>
<Paragraph position="23"> Although these definitions suffice for most examples of coordination, it is not sufficiently constrained enough to reject stone ungr,'mzmatical examples. For exaanple, fig. 5 gives the RPM representation of &amp;quot;*John sang loudly and a carol&amp;quot; in terms of the union of the RPMs for the two  (When thcse two I\[PM.q are merged some of the elements o\[ the set do not satisfy La.snik &amp; gupin '~ ongimd deAuitiou - thc.~e \[rdrs arc :-) {John.sang.loudly. John sanff.a.carol} {John.V.loudly. John.V.a.carol} {NP.sang.loudly. NP.sang.a.carol} (N,m. o\[ the show: I~xirs .~lt/.st'y the e-dominates prw/irate - but Lhcy all .~tisfy e-precedes and hence the sentcm:e Js ac~eptc~l as .~, RI'M.) Fig.5: An example ot&amp;quot; union o\[ RPMs The above example indicates that the extended RPM definition of Goodall Mlows some ungrammatical sentences to slip through. Although the device preseuted in the next section doesn't make direct use of the extended definitions, the notion of equivMence is central to the implementation. The basic system described in the next section does have this deficiency but a less simplistic version described later is more constrained - at the cost of some computational efficiency.</Paragraph>
<Paragraph position="24"> Linearization and Equivalence Although a theory of coordination ham been described in the previous sections - in order for the theory to be put into practice, there remain two important questions to be answered :* I-low to produce surface strings from a set of sentences to be conjoined? * tlow to produce a set of simple sentences (i.e. sentences without co,junct.ions) from ~ conjoined surface string? This section will show that the processes ot&amp;quot; //ne~zation and finding equivalences provide an answer to both questions. For simplicity in the following discussion, we assume that the number of simple sentences to be conjoined is two only.</Paragraph>
<Paragraph position="25"> The processes of linearization ~md 6riding equivalences for generation can be defined as :-Given a set of sentences and a set of candidates which represent the set of conjoinable pairs for those sentences, llnearizatinn will output one or more surface strings according to a fixed procedure. null Given a set of sentences, findinff equivalences will prodnce a set o( conjoinable pairs according to the definition of equivalence o# the linguistic theory.</Paragraph>
<Paragraph position="26"> \[;'or genera.Lion the second process (linding equivalences) iu caJled first to generate a set of (:andidates which is then used in the first, process (linearization) to generate the s.rface strings. For parsing, the definitions still hold but the processes are applied in reverse order.</Paragraph>
<Paragraph position="27"> To illustrate the procedure for linearization, consider the following example of a set of simple sentences (fig. 0) :.</Paragraph>
<Paragraph position="28">  The procedure of linearization would t~tke the foil.wing path shown by the arrows in fig. 8 : null F~dlowin K the path shown we obtain the surface siring &amp;quot;John and Mary liked ice-cream and chocolate&amp;quot;. The set of conjoinable pairs is produced by the process of \[inding equivalences. The definition of i:quivalence as given in the description of the extended RPM requires the general.ion of the combined R.PM of the constituent senlances. However it can be shown \[I,'ong??\] by considering the constraints impc,sed by the delinitions of equivalence and linc:trization, that tile same set of equivalent terminal string.~ can be produced just by using the terminal strings of the RI*M alone. There ;tre consider;Lble savings of computatioaal resources in not having to compare every element of the set with every other element to generate all possible equivalent strings - which would take O(n ~) time - where n is the cardinality of the set. The corresponding term for the modified definition (given in the next sectiou) is O(1). The Implementation in Prolog This section describes a runnable specification written in Prolog. The specification described also forms the basis for comparison with the MSG interpreter of Dahl aud Me-Cord. The syntax of the clauses to be presented is similar to the Dec-10 Prolog \[Bowen et a1.19821 version. The main differences are :* The symbols %&amp;quot; and ~,&amp;quot; have been replaced by the more meaningful reserved words &amp;quot;if&amp;quot; and &amp;quot;and&amp;quot; respectively. null * The symbol &amp;quot;.&amp;quot; is used ,as the list constructor and &amp;quot;nil&amp;quot; is ,,sed to represent the empty list.</Paragraph>
<Paragraph position="29"> * ,in an example, a Prolog clause may have the fornt :a(X V ... Z) ir b(U v ... W) a~d c(R S ... T) where a,b &amp; c are predicate names and R,S,...,Z may represent variables, constants or terms. (Variables are ,listinguished by capitalization of the first character in the variable name.) The intended logical reading of tile clause is :&amp;quot;a&amp;quot; holds if &amp;quot;b&amp;quot; and &amp;quot;c&amp;quot; both hold for consistent bindings of the arguments X, Y,...,Z, U, V,..., W, R,S,...,T * Cmnments (shown in italics) may be interspersed between tile argamaents in a clause.</Paragraph>
<Paragraph position="30">  In tile previous section tile processes of linearization and linding equivalences are described ;m tile two components necessary for parsing and generating conjoined sentestes. We will show how Lhese processes can be combined to produce a parser and a generator. The device used for comparison with Dahl &amp; McCord scheme is a simplified version of the device presented in this section.</Paragraph>
<Paragraph position="31"> First, difference lists are used to represent strings in the following sections. For example, the pair (fig. 9) : null is a difference list representation of the sentence &amp;quot;John liked ice-cream&amp;quot;.</Paragraph>
<Paragraph position="32"> We can :tow introduce two predicates linearize and equivaleutpalrs which correspond to the processes uf liaearization uJl(l liuding equivalences respectively (fig. 10) :linearize( pairs S1 El and 52 E2 candidates Set yivcs Sentence) Linearize hohls when a pair of difference lists ({S1. EL} &amp; {S2. E2)) and a set ,,f candidates (Set) arc consistent with the string (Sentence) as dellned by the procedure given in the previous section.</Paragraph>
<Paragraph position="34"> Equivalentpairs hohls when a ~uhstring X of S1 is equivalent to a substring Y of $2 accordhtg to the delinition of equivalence in the linguistic theory.</Paragraph>
<Paragraph position="35"> The definitions fi~r parsing ,'utd generating are almost logically equivalent. Ilowever the sub-goals for p~sing are in reverse order to the sub-goals for generating since the Prolog interpreter would attempt to solve the sub-goals in a left to right manner. Furthc'rmore, the sub-set relation rather than set equality is used in the definition for parsing. We can interpret the two definitions ~ follows (fig. t2):-Generate holds when Sentence is the conjoined sentence resulting/'ram the linearization of the pair of dilFerence lists (Sl. nil) and (52.</Paragraph>
<Paragraph position="36"> nil) using as candidate pairs for conjoining, the set oPS non-redundant pairs of equivalent terminal strings (Set).</Paragraph>
<Paragraph position="37"> Parse holds when Sentence is the conjoined set, tence resulting from the linearization of the pair of dilference lists (S1. El) anti ($2. E2) provided that the set of candidate pairs for conjoining (Subset) is a subset of the set of pairs of equivalent terminal strings (Set).</Paragraph>
<Paragraph position="38"> Fig 12: Logical readhtg for generate &amp; parse Fig 10: Predicates llneari~.e &amp; equivalentpairs Additionally, let the mete-logical predicate ~etof as in &amp;quot;setof(l~lement Goal Set)&amp;quot; hohl when Set is composed of chin,eats c~f the form Element anti that Set contains all in,: auccs of Element I, hat satisfy the goal Goal. The predicates generate can now be defined in terms of these two processes as folluws (lig. t t) : null The subset relation is needed for the above definition of parsing hecause it can be shown \[Fong?? l that the process of linearization is more constrained (in terms of the p,.rn~issible conjoinable pairs) than the process of tinding eqnivalences.</Paragraph>
<Paragraph position="39"> Linearize We can also fashion a logic specification for the process of line~tt'izatiou in the same manner. In this section we will describe the cases corresponding to each Prolog clause necessary in the specification of \[inearization. However, ,'or sitnplicity the actual Prolog code is not shown here. (See Appendix A tbr the delinition of predicate Iinearize.) Ill the following discussion we assume that tile template for predicate Iinearize has the form &amp;quot;linearize( pairs Sl El and 52 E2 rand,tides Set gives Sentence)&amp;quot; shown previously in tig. I0. There are three independent cases to con:rider durivg !incariz~tion ft. The Base Case.</Paragraph>
<Paragraph position="40"> If the two ,lilrcrence tist~ ({S1. El} &amp; {S2. E2}) are both empty then the conjoined string (Sentence) is also entpty. This siml,ly sta.tes that if two empty strings arc conjoint:d then the resttit is also an empty string.</Paragraph>
</Section>
</Paper>

