<?xml version="1.0" standalone="yes"?>

<Paper uid="W96-0413">
<Title>An Algorithm for Generating Quantifiers</Title>
<Section position="1" start_page="0" end_page="123" type="abstr">
<SectionTitle>
Abstract:
</SectionTitle>
<Paragraph position="0"> Quantifiers, and their associated scoping phenomena are ubiquitous in English and other natural languages, and a great deal of attention has been paid to their treatment in the context of natural language analysis. Rather less attention, however, has been paid to their treatment in the context of language generation. This paper describes an algorithm for generating quantifiers in English sentences which describe small models containing collections of individuals which are inter-related in various ways. The input to the algorithm is, i) a model represented as a collection of facts and ii) an abstract description of the target sentence with gaps where the quantifiers should be.</Paragraph>
<Paragraph position="1"> Keywords: lexical choice, realisation, quantifiers  An Algorithm for Generating Quantifiers Quantifiers, and their associated scoping phenomena are ubiquitous in English and other natural languages, and a great deal of attention has been paid to their treatment in the context of natural language analysis (Alshawi 1990, Creaney 1995, Grosz et al.</Paragraph>
<Paragraph position="2"> 1987, Hobbs and Shieber 1987, Park 1995, Saint-Dizier 1984). Rather less attention, however, has been paid to their treatment in the context of language generation. This paper describes an algorithm for generating quantifiers in English sentences which describe small models containing collections of individuals which are inter-related in various ways.</Paragraph>
<Paragraph position="3"> A model is represented as a collection of facts like the following:  rep( rl ). sample( sl ).</Paragraph>
<Paragraph position="4"> rep( r2 ). sample( s2 ).</Paragraph>
<Paragraph position="5"> rep( r3 ). sample( s3 ).</Paragraph>
<Paragraph position="6"> rep( r4 ).</Paragraph>
<Paragraph position="7"> saw( rl, sl ).</Paragraph>
<Paragraph position="8"> saw( r2, sl ).</Paragraph>
<Paragraph position="9"> saw( r2, s2 ).</Paragraph>
<Paragraph position="10"> saw( r3, s2 ).</Paragraph>
<Paragraph position="11"> saw( r3, s3 ).</Paragraph>
<Paragraph position="12"> saw( r4, sl ).</Paragraph>
<Paragraph position="13"> saw( r4, s2 ).</Paragraph>
<Paragraph position="14"> saw( r4, s3 ).</Paragraph>
<Paragraph position="15">  In model (1) there are four representatives and three samples and some of the representatives saw some of the samples. The algorithm generates suitable quantifiers to complete sentences of the form: QR representative(s) saw Qs sample(s) where QR and Qs can be arbitrary quantifiers like; some, two, all, both, one of the, most, etc. The algorithm also handles models containing more relationships than model (I) to generate sentences of the form:</Paragraph>
<Paragraph position="17"> One of the most striking things about the problem is that there are generally a great many sentences which provide reasonable descriptions of any given model. For example, the following are all acceptable for model (1).</Paragraph>
<Paragraph position="18">  It turns out that there are three distinct sources of this variation and they correspond to three different kinds of choices which are made in the generation algorithm. They are: o quantifier scoping choices o choice of focus sets o choice of individual quantifiers constrained by the above two choices A great deal has been written about the quantifier scoping problem for natural language analysis (Hobbs &amp; Shieber 1987) and much of this is applicable to the generation problem in the sense that any particular description must assume some particular quantifier scoping arrangement. For example, sentence (2) assumes that &amp;quot;Every representative&amp;quot; has wide scope while sentence (5) assumes that &amp;quot;every sample&amp;quot; has wide scope, and the sentences are only satisfied in the model under these assumptions. In fact sentences (2), (3) and (4) all assume wide scope for &amp;quot;representative&amp;quot; while sentences (5), (6) and (7) all assume wide scope for &amp;quot;sample&amp;quot;. The gencration algorithm, of necessity, incorporates quantifier scoping.</Paragraph>
<Paragraph position="19">  The concept of a focus set has no correlate in the language analysis literature although it is similar to what Barwise and Cooper (Barwise and Cooper 1981) call a witness set. It has to do with choosing some particular subset of the model on which to base the description.</Paragraph>
<Paragraph position="20"> Sentence (2) talks about all three representatives while sentence (4) talks only about the subset {r2,r3,r4}. This subset stands in the realtion most to the entire set of representatives {rl,r2,r3,r4} and is the focus set for R in sentence (4). The concept of a focus set will be made more precise below where dependency functions are discussed.</Paragraph>
<Paragraph position="22"> and the purpose of the algorithm is to assign values to the Oi's given some suitable model.</Paragraph>
<Paragraph position="23"> It works by processing the PAS recursively and non-deterministically selecting quantifier scopings and focus sets at each level.</Paragraph>
<Paragraph position="24"> Quantifiers are then generated based on the cosen focus set.</Paragraph>
<Paragraph position="25"> Inputs to the algorithm The inputs to the algorithm are: a model like (1) a predicate argument structure for the target sentence A predicate argument structure (PAS) is essentially an unscoped logical form of the form taken as input to Hobs and Shieber's algorithm (Hobbs &amp; Shieber 1987). It makes explicit the relationships between predicates and there arguments but does not express any quantifier scope relationships. Sentence (2) has the following PAS: saw(every(R,rep(R)), a(S,sample(S)) ) Quantifier scoping Since the particular scoping framework underlying the generation algorithm is novel a brief explanation is appropriate. The orthodox approach to quantifier scoping is embodied in Hobbs and Sheiber's algorithm and it permits all permutations of quantifiers such that there are no unbound variables in the resulting logical form. For example, Hobbs and Shieber's algorithm produces the scopings  and sentence (8a) has the following one. saw( every(R, rep(R)Aof(R,a(C,com(C))), some(S, sample(S)) ) Each variable in a PAS has a quantifier and a restriction which restricts the values which it may take.</Paragraph>
<Paragraph position="27"> S's restriction is sample(S) in both cases R's restriction is rep(R) in the first PAS and rep(R)Aof(R,a(C,company(C)) in the second Since the algorithm generates quantifiers its input PASs are not exactly like these. Instead they have gaps where quantifiers should be: where R &gt; C &gt; S indicates that &amp;quot;Every representative&amp;quot; outscopes &amp;quot;a company&amp;quot; which in turn outscopes &amp;quot;some samples&amp;quot;. The missing permutation, R &gt; S &gt; C, is not permitted because it violates what has become known as the unbound variable constraint.</Paragraph>
<Paragraph position="28"> The scoping framework which underlies the generation algorithm recognises fewer scopings than (8). The relative scope of two quantifiers is only considered for variables We adopt the convention of naming variables with the first letter of the head noun with which they are associated (R=representative, C=company, S=sample) and using the symbol '&gt;' to denote relative scope.</Paragraph>
<Paragraph position="29">  which are arguments to the same predicate.</Paragraph>
<Paragraph position="30"> For example, R must be scoped relative to C because they are both arguments to the predicate of The possibilities are R &gt; C and t3 &gt; R. Similarly, R and S are arguments to the predicate saw and may be scoped either R &gt; S or S &gt; R. The relative scoping of C and S is never considered directly because they do not participate directly in any single predication in the sentence. They may however end up with a relative scoping as a result of taking the transitive closure of other scoping relationships. For example, if it is decided that C &gt; R and R &gt; S, then clearly, since scope is transitive, C &gt; R. In this framework the following scopings are allowed for (8a).</Paragraph>
</Section>
</Paper>

