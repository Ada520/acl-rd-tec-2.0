<?xml version="1.0" standalone="yes"?>

<Paper uid="J96-3001">
<Title>Unification Encodings of Grammatical Notations</Title>
<Section position="2" start_page="0" end_page="0" type="abstr">
<SectionTitle>
1. Introduction
</SectionTitle>
<Paragraph position="0"> Formalisms equivalent to, or based on, unification grammars of the type exemplified by PATR (Shieber 1984) are very widely used in computational linguistics (Alshawi 1992; van Noord et al. 1990; Briscoe et al. 1987; Bobrow, Ingria, and Stallard 1991, etc.) A unification-based formalism has many well-known virtues: it is declarative, monotonic, reversible (in principle at least); it has a well-understood formal interpretation (Shieber 1986, Smolka 1992, Johnson 1988); and there exist well-understood and relatively efficient parsing and generation algorithms for grammars using such a formalism (Shieber 1988; Haas 1989; Alshawi 1992; Shieber et al. 1990, inter alia).</Paragraph>
<Paragraph position="1"> However, a pure unification formalism is often thought to be a somewhat restricted grammatical formalism, especially when compared with the rich devices advocated by many grammarians. The recent literature (Pollard and Sag 1987, 1993, etc.) uses many devices that go beyond pure unification: set valued features; negation and disjunction; tests for membership; list operations like &amp;quot;append&amp;quot; and &amp;quot;reverse&amp;quot;; multiple inheritance hierarchies; as well as Kleene operators like * or +1, which are familiar from linguistics textbooks although they have no direct equivalent in a unification grammar.</Paragraph>
<Paragraph position="2"> Unfortunately, there is a price to pay for this increase in expressive power: a decrease in efficiency. Whereas there exist several relatively efficient implemented systems for parsing and generating with wide-coverage &amp;quot;pure&amp;quot; unification grammars (Alshawi 1992; Briscoe et al. 1987), more complex formalisms have not so far led to systems of comparable efficiency. At the present time, I am not aware of any practical implementations using these more complex descriptive devices remotely comparable to the (relative) efficiency of pure unification-based systems when used with wide-coverage grammars and large lexica. This is not a claim that the efficiency problem is solved even for pure unification grammars, but it is at least less of a problem than for these richer formalisms.</Paragraph>
<Paragraph position="3"> * Suite 23, Miller's Yard, Mill Lane, Cambridge CB2 1RQ, UK (~) 1996 Association for Computational Linguistics Computational Linguistics Volume 22, Number 3 It would therefore be desirable to combine the efficiency of pure unification-based systems with the availability of richer grammatical formalisms. One route to this happy state of affairs would be to develop efficient processing mechanisms for the richer devices directly. However, this route involves a research program of uncertain length and outcome, given the known complexity properties of many of the richer descriptive devices.</Paragraph>
<Paragraph position="4"> This paper describes an alternative approach towards such a combination, via the compilation of apparently richer grammatical notations into expressions whose satisfaction can be checked by unification alone. Compilation of these apparently richer devices into expressions that can be processed just using unification will generally allow the grammarian to use them freely, without necessarily sacrificing the advantages of efficiency that pure unification systems offer. I say &amp;quot;without necessarily sacrificing&amp;quot; efficiency, because some compilation strategies may actually make matters worse. For example, a naive compilation of disjunction into many alternative rules and lexical entries, combined with an equally naive parsing algorithm, may produce worse behavior than an implementation that interprets the disjunctions directly.</Paragraph>
<Paragraph position="5"> The paper describes a variety of apparently richer descriptive devices that can be compiled into unification grammars in ways that under normal circumstances will result in efficient processing. Some I believe to be original; others have been described elsewhere in the literature in some form, although often in a way that makes it difficult for computational linguists to appreciate their significance. Still others are known mostly by word of mouth, in the unification grammar community. The intention of the present paper is to describe them all in an accessible form (hence the more tutorial tone than is usually found in this journal) and thus attempt to narrow the gap between rich grammatical formalisms and efficient practical implementations.</Paragraph>
<Paragraph position="6"> Of course, you don't get anything for nothing in this game. There will still be cases where the full power of the richer formalisms is necessary. The various techniques described here are often limited in their applicability, applying to only a subset of the problems that one would like to solve. Furthermore, some of the techniques described can lead, in the worst case, to overwhelmingly large structures and consequent processing inefficiency. Nevertheless, practical experience has shown that (with care and some experimentation) it is possible to develop linguistic descriptions that are succinct and relatively elegant, while still lending themselves to efficient (and most importantly, bidirectional) processing.</Paragraph>
</Section>
</Paper>

