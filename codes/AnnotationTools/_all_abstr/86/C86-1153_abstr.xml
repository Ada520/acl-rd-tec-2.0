<?xml version="1.0" standalone="yes"?>

<Paper uid="C86-1153">
<Title>Construction of a modular and portable translation system</Title>
<Section position="1" start_page="0" end_page="650" type="abstr">
<SectionTitle>
i. Introduction
</SectionTitle>
<Paragraph position="0"> In recent years the study of nlachJ ne trans\].ation has made great advances and the translation system has been larger and complicated wJ th augmenting faei\] \]ties. Furthermore, most recently, many powerfu\[ workstations have been developed and wtrious MT systems for special purposes are ready to be mounted on these workstations.</Paragraph>
<Paragraph position="1"> \]in snch a state of affairs Jt will be needed that many MT systems are reorganized or reconstructed on a program module basis for easy modification lllaJ ntainance and transplantation. '\]'h:is paper has two purposes. One of th~i~l :{s to show a method of constructing an MT system ~'3&amp;quot; on a library module basis by the aids ~ a progralnming construction system called L-MAPS. ~) The M\]' system can be written in any progranm~Jng language designated by a user if an appropriate data base and the appropriate processing functions are imp\].emented in advance. For example, it call be written in a coml)i\].er language like C \]aeguage, which Js preferable for a workstation with a relative slow running machine speed. 4) The other purpose is to give a brief :introduction of a program generating system called Library-Modul.e Aided Program SynthesizJ ng system (abbreviated to \[,-MAPS ) running on a library module basis. L-MAPS permits us to write program specifications in a restricted natural \]anguage like Japanese and converts them to formal specifications. It refines the formal specifications using the library modules and geeerates a readable comment of tile refiined specification written in tlre above natural language every refinement in option.</Paragraph>
<Paragraph position="2"> Tim conversion between formal expressions and natural language expressions is performed efficient\]y on a case grammar basis.</Paragraph>
<Paragraph position="3"> * 2):~) 2. Overview of the MT system organizat\].on Our machine translation system is constructed on the intermediate expressions based on universal subframes of predicates and predicative nouns. It aims at a multiliugual transfer system. \[\]p to now, however ~ no universal precise semant J c category system over various languages has been constructed yet, and our MT system is compelled to work rather on a bilingual basis in the selection of equivalent.s, The first versio~of the par~q~ was written in an extended version &amp;quot; of LINGOL -'~'. It has an advice part and a semantic part in each rewriting rule. Both parts of them pernlit users to describe any Lisp program for designating details of the reduction procedures. These techniques used Jn LINGOL and ATN seem apparently convenient. However, they often make the data part inseparable from the program part and bring an MT system to much complexity, and accordingly, prevents applicability of tire programs of the MT system Lo another translation between other languages.</Paragraph>
<Paragraph position="4"> Recently, a revised version of our MT system has been constructed, rfhe main program or procedural part cons:i sts of uni f:i cat\] on arKl substJtut:ion, while the data part consists of frame knowledge rewriting ruins and word dictionaries.</Paragraph>
<Paragraph position="5"> Rewriting ru\]es wi th arguments describe the details of the syntactic and semantic structure of the language explicitly. For example, the predicate part: of the Hornby's verb llattern VP\]3A of Eagl:ish is written as follows:</Paragraph>
<Paragraph position="7"> where PREDP, VP, NP and PP denote a PR\]'\]DJcage Phrase, a Verb Phrase, a Noun Phrase and a Prepositional Phrase respecively, k-c:t denotes a triple of a case label, a semantic category and a term and in denotes var:ious modal values such as tense an(\] aspect. These rewriting rules are tabnlated in several tab\] es :\[or an effJ (lent processJ ug.</Paragraph>
<Paragraph position="8"> The parsing system first applies the syntactic part of a rewriting rule to that of a handle in a reduction sequence of a given source sentence, ff tile system finds a unJf:iable rewriting rule, :it checks whether the semantic part is unifiable. \]'he category check of a term in a handle for the case-frame condition is processed by a special kind of unification under an interpretation that the term category in a rule :is a restricted variable.</Paragraph>
<Paragraph position="9"> The intermediate expression of tile handle part is constructed by substituting the unified terms for the arguments in the left-hand side of the  rewriting rule.</Paragraph>
<Paragraph position="10"> 3. The L-MAPS system aud language conversion  The L-MAPS system is costructed on a fundamental \].ibrary module basis. When a user gives a specification by referrkng to the libraly module, L-MAPS searches applJ(.:able library modules and refines the spa(if J cation by linking several modules or replacing :it by the detailed procedure called the Operation Part of an applicable library module. The formal specifications of programs as well as tile library modules are generally difficult for users to read and write correctly though they are efficient and rigorous for inachine operation. Hence, it is desirab\].e to rewrite the formal specification Jn a natural l.anguage. I.-MAPS performs a conversion between a restricted natural language expression and a fornlal language expression through the intermediate (or the internal) expression of the natural language expression with the aids of case \].abels.</Paragraph>
<Paragraph position="11"> The conversion between a restricted natural language expression and the intermediate expression can be done Jn a similar manner to the conversion carried out in machine translation.</Paragraph>
<Paragraph position="12"> Formal specifications generaJ.ly have different forms from those of the intermediate expressions.  The intermediate expression of a sentence takes the following form : (PRED:tp, Kl:tl ....... Kn:tn) (I) where PRED K1 and Kn are case labe\].s and tp tl and tn are terms corresponding to their casesdeg On the other hand, a procedure expression appearing in formal specifications as well as in a heading of each library module has tile following form: proc-label(Kl':tl', K2':t2', ..... Kri':tn') (2) where the procedure name plays a role of the key word and it is constructed from the predicate term the object term and others of the intermediate expressiondeg It is used for retrieving library modules applicable to a given specification.</Paragraph>
<Paragraph position="13"> \].-MAPS performs the conversion between the intermediate expression(I) and the procedural expression(2) by a method similar to the case structure conversion between different languages. The conversion :ks applied not onJy to the construction of a formal specJ fJeation from an informal specificatJ on written Jn restricted Japanese or English but also to the generation of Japanese or English comments on the refJ ned specifications generated by L-MAPS itself.</Paragraph>
<Paragraph position="14"> 4. Modularization of programs The revised MT system is reconstructed based on library modules by the aids of L-MAPS. Each library module has a structure as shown in Table i.</Paragraph>
<Paragraph position="15">  The heading of each module has both the procedural expression and the input-output predicate expression (abbreviated to the IO expression).</Paragraph>
<Paragraph position="16"> Program specifications given by a user can call a module by using one of these headings.</Paragraph>
<Paragraph position="17"> The IO expression consists of a pair of an input and an output predicate and asserts that the output predicate holds under the given input predicate.</Paragraph>
<Paragraph position="18"> The IO expressions are used to automatically link some modules for a specification and to check linking of modules specified by their procedural expressions.</Paragraph>
<Paragraph position="19"> The type part describes the types of regions structures and roles of input output or local variables.</Paragraph>
<Paragraph position="20">  Tile OP part describes the procedures for the ~nnction assured in the heading part. \]'he procedures are described in a little more detail by using tile headings of more fundainental modulesdeg Control statements are represented by using a prefixed-form of Pascal called the General Control Expression (abbrewkated to GCE,) heredeg The control statements are expanded into a programming language such as L:isp and C designated by users. Some conversion rules are shown in Table 2.</Paragraph>
<Paragraph position="21"> Table 2 Conversion rules to objective lauguages IF TIIEN(CONI): p. OP: s .................... (GCE)</Paragraph>
<Paragraph position="23"> Corresponding to tlle genera\] control \]anguage~ general data structures are also introduced. If refined specifications are designated to be expanded to a programming language which do not have the corresponding data structures inherently, the equivalent data structures and the access function must be imp\].emented in advance by combining the fundamental data structures in the language. For example, if Lisp is designated as the programming language, a struct which appears in a general data structure of a specification is expanded to the correspondig associative list structure and the lists can be accessed by associative functions.</Paragraph>
<Paragraph position="24">  5. Refinement and Expansion by the L-MAPS system  In refinement, L-MAPS tries to un:i.fy the heading el an expression in a given speeifJcation and the corresponding heading of a l:ibrary module. If L-MAPS succeeds in the unification, it constructs a more detaJ\]ed description of the specificatfion by using the unified Operation Part of the module .</Paragraph>
<Paragraph position="25"> The refined part with a more detailed description can be substituted directly for the original part in the specification or can be called in a form of a subprogram as a procedure or a dosed subroutine from the specification part. One of them is selected by the user.</Paragraph>
<Paragraph position="26"> The principal part of the above refinement is unification of a specification and the heading of a library module. When the arguments of a module are confined to the individual variables and the number of arguments of a function is confined to a constant the unification caa be carried out; by an ordinary unification of the first order logic. 0therwJse, the unification procedure for the second order ilogic is needed.</Paragraph>
<Paragraph position="27"> L-MAPS has a unification procedure for the second order logic. IIowever, the un~ fJcatJon procedure is confined to a unilateral unification from a module to a specification in which each symbol is J nterpreted as a constant under the condition that any substitution for the symbol Jn the specifications is forbidden. Accorddagly, the unification procedure can be much simplified for practical purpose.</Paragraph>
<Paragraph position="28"> Fig.2 shows parts of a given specification written in the restricted English for a parsing program of EngIish sentences and Fig.3 shows a part of the generated formal specification.</Paragraph>
<Paragraph position="29"> ...,.,,...........,.....,dego for i from i to m js:=j search handles from reducedsequences(i) by using reduction rules, and store it in handle(l..k) and rule(\[..k) if k is greater than 0 for n from 1 to k reduce handle(n) Jn reduced_sequences(i) by using rule(n), and store the result in  apply t:he rnl.e to the handle, and store t;he result; in a reduced symbol.</Paragraph>
<Paragraph position="30"> Jf the reduced_symbol Js null return(fail).</Paragraph>
<Paragraph position="31"> for n from t. t:o stack_po:inter-synlbol_number of hand\] e copy reducedsequence(n) :into new reduced sequence(n).</Paragraph>
<Paragraph position="32"> .o................,...,....</Paragraph>
<Paragraph position="33"> Fig.4(b) The comments of the refined specification in Fig.4(a) In the refinement process global optimizations are tried to be done at the user's option. Some of them are rearrangement of conditional control statements and fusion of several iteration loops :i.nto one loop.</Paragraph>
</Section>
</Paper>

