<?xml version="1.0" standalone="yes"?>

<Paper uid="C86-1114">
<Title>LexicaI-Functional Grammar: A Formal System for Grammatical Representation in: Bresnan, Joan (ed): The Mental Representation of Grammatical</Title>
<Section position="1" start_page="0" end_page="484" type="abstr">
<SectionTitle>
ZT ZTI INF
</SectionTitle>
<Paragraph position="0"> W. Germany In this paper we propose a way of how to treat long-distance movement phenomena as exemplified in 1) in the framework of an LFG-based parser.</Paragraph>
<Paragraph position="1"> (1) Who do you think Peter tried to meet 'You think Peter tried to meet who' We therefore concentrate first on the theoretical status of so called wh- or long-distance-movement in Lexical Functional Grammar (LFG) and in the Theory of Government &amp; Binding (GB), arguing that a general mechanism that is compatible with both LFG and GB treatment of long-distance-movement can be found. Finally we present the implementation of such a movement mechanism in a LFG-Parser.</Paragraph>
<Paragraph position="2"> The basic principles of the treatment of long distance phenomena or constituent control in LFG as described in (Kaplan/Bresnan 1982) can be characterized roughly in the following way: 1. The contextfree grammar is augmented by productions expanding to the empty word: XP~e By the means of these productions traces are introduced at the &amp;quot;originating&amp;quot; position of a &amp;quot;displaced&amp;quot; constituent or speaking more in LFG terms a phonetically empty constituent is introduced at a c-structure position (the controllee constituent) whose role in the f-structure is to be played by the lexically specified linearly and structurally displaced constituent (the controller constituent).</Paragraph>
<Paragraph position="3"> 2. Besides the immediate domination metavariables ($, ~) another type of metavariables is used, the bounded domination metavariable, the doubleups and double-downs here represented t T as and $ $ for convenience. In contrast to the immediate domination variables, which allow to express identities of f-structures or f-structure parts assigned to c-structure nodes standing in the relation of immediate domination, the bounded domination metavariables allow to identify the f-structures of two c-structure nodes far apart in the c-structure.</Paragraph>
<Paragraph position="4"> The use of these metavariables can be seen in the following LFG grammar rules, where the symbol that introduces the controller constituent has among its equations one ofthe form $ = $ $ and the empty word is associated with the equation ~ = ~ ~.</Paragraph>
<Paragraph position="6"> The instantiation procedure for these bounded domination variables thereby is defined such that it identifies the f-structures of the controller and controllee in a way which is shown in the following schematical description in figure 1 for a sentence like (2), leading to f-structures with shared substructures.</Paragraph>
<Paragraph position="7">  (2) \[S' \[NP who\]\[s does he try to find \[NP e\]\]s IS'</Paragraph>
<Paragraph position="9"> who does he try to find e Figure 1 In addition to the basic approacl~ presented so far there are some more means for expressing the various cstructurally defined constraints that have to be fullfilled in order to be allowed to identify two constituents' f-structures in the way just described and thereby rule out a lot of otherwise possible but ungrammatical structures.</Paragraph>
<Paragraph position="10"> The central additional mechanism to deal with these restrictions governing the possibliliy of establishing the constituent-control relation between two constituents is the use of bounding nodes. In LFG these are not specified globally but introduced at a rule specific basis, allowing for a natural treatment of the various idiosyncratic constituent control constructions in various languages that withstand a grammatical description by means of global bounding categories (see Kaplan/Bresnan (1982:245f) for a deeper discussion !). Thus for example in the following VP- and S'-expansion introducing a sententiell wh-complement, the marking of S as bounding node accounts for the ungrammaticality of (3).</Paragraph>
<Paragraph position="12"> (3) *What does he\[vp wonder Is' whether \[s she wants \[NP e\]\]s' \]S\]VP The blocking of structures like these is achieved by permitting no bounding node to lie on the path between the empty constituent and the root node of the control domain, which is specified as annotation of the ~ g-meatvariable ($ St), shown in the following  rule.</Paragraph>
<Paragraph position="14"> With the fragmentary grammar rules just presented the identification of 'what with 'e&amp;quot; in the embedded clauses object position is prevented as shown in Figure</Paragraph>
<Paragraph position="16"> what does he wonder wether she wants e Figure 2 Here the occurrence of the bounding node (S) in the tree structure dominated by the root node of the constituent control domain effectively makes the Sdominated subtree inaccessible to any constituent control from outside.</Paragraph>
<Paragraph position="17"> to constituent control (as categorial subscripts and additional feature restrictions) are not described as we do not treat them in our implementation.</Paragraph>
<Paragraph position="18"> In the GB~framework wh-Movement is regarded as an instance of the general transformation &amp;quot;move ct&amp;quot;. The wh-Phrase is moved out of its position (a.) into the COMP-Position dominated by S' and thereby leaves a trace in its original D-structure position (b.).</Paragraph>
<Paragraph position="19">  (4) a. \[S'__ \[s haveyou done whati\]s \]s' b. \[s' whati \[s haveyou done ti\]s\]s' wh-Movement underlies the constraint of subjacency but may be applied cyclically via the COMP-position, leaving traces in any COMP-position it meets: (5) \[s' whoi \[s do you think Is' ti\[S Peter wants Is' ti\[s PRO to  meet ti IS \]S' \]S \]s'\]s \]s' This assumption explains the ungrammaticality of (6) by the mere fact that the possible intermediate landing site for what is occupied by who.</Paragraph>
<Paragraph position="20">  (6) *\[s' Whati \[s doyou think \[S' whoj \[s tj did ti\]s \]S' \]s \]s' Furthermore this assumption explains the ungrammaticality of (7a) by the absence of a COMP-position in NP and the assumption that NP is a bounding node.</Paragraph>
<Paragraph position="21"> (7) a. *\[s' Whoi \[s do you believe \[NP the claim \[S' ti that \[s John loves ti\]s \]S'\]NP\]S\]S' b. \[s' Whoi do you think that \[s John loves ti\]s\]s'  From a technical point of view, leaving aside philosophical and psychological reflections on universal grammar and learnability, the main difference between the two theories regarding wh-Movement can be seen in the following.</Paragraph>
<Paragraph position="22"> 1) Whereas in LFG the application of wh-Movement is constrained by bounding nodes in GB it is constrained by bounding categories. G8 is more restrictive in this point and aims towardsa greater generalization, as it is excluded for two nodes with the same category to have different bounding node characteristics. 2) In GB the principle of subjacency which roughly says that no movement may cross two or more bounding nodes is used to explain the difference in grammaticality of (7a) and (7b) above. In LFG the same ungrammaticality is explained by the identity of the root node and the bounding node. The root node - being by definition a sister of the moved phrase - defines the subtree in which the trace for the moved phrase can and must be found. The fact that this root node may be crossed even if it is a bounding node but that the search is blocked if another bounding node is encountered evoques the subjacency effect.</Paragraph>
<Paragraph position="23"> 3) The grammaticality of (5) is explained in GB by cylic COMP-to-COMP-movement. The NP in question is first moved into the first COMP-positon without violation of subjacency. Form there it is moved again without violation of subjacency - to the next COMP-position. In LFG these facts are described by an additional grammar rule. The two rules for S'</Paragraph>
<Paragraph position="25"> grammar-modules long-distance-movement is treated in, In GB the movement is treated in a strictly constitutional way. It is part of the grammar's movement-rule-module and operates on nothing but positions. In LFG, long-distance movement is associated with the c-structure part of the grammar as well as with the part that is repsonsible for the instantiation of the variables, especially the bounded domination metavariable. Thus - although being introduced via phrases in the c-structure rules - it effectively does not operate on phrases but on functional variables.</Paragraph>
<Paragraph position="26"> (According to Ron Kaplan (personal communication) a totally f-structure-oriented approach of such phenomena will be given m the ongoing development of LFG, whose exact elaboration is forthcoming) When constructing our parser we found it very enlighting to &amp;quot;merge&amp;quot; the two theories in the following way. We consider subjacency as an epiphenomenon of the fact that 1) bounding nodes are strict boundaries for movement and 2) a bounding node may be  crossed if it is a root node (as in LFG).</Paragraph>
<Paragraph position="27"> adapt the more flexible LFG view of (rule-specific) bounding nodes instead of bounding categories, as one can anyway derive bounding nodes from bounding categories by replacing every occurrence in the grammar rules' right hand side of a bounding category by the bounding-nodemarker. null prefer the principle of cyclicity'over equations of the type $ $= $ $~ treat movement strictly constitutionally.</Paragraph>
<Paragraph position="28"> Our parser is based on Earley's (1970) algorithm augmented by a mechanism for treating long-distance phenomena according to the above mentioned principles. The basic context-free parser operates on two ordered sets of states that correspond to the state sets si and si+ 1 in the Earley-Parser to the end of which  constantly new states which are still to be worked on are added. A state is a quintupel (&lt;tree&gt; &lt;left&gt; &lt;right&gt; &lt;dot&gt; &lt;pred.-list&gt;).</Paragraph>
<Paragraph position="29"> - &lt;tree &gt; is the current parsetree of that path, - &lt;left&gt; and &lt;right&gt; are pointers to the input string the constituent begins with and the input string that immedeately follows the constituent respectively, - &lt;dot&gt; marks the current position in the right side of the cf grammar rule and &lt;pred.-list&gt; is a set of pointers to all preceeding states who's treenodes might become the mother of current states' tree.</Paragraph>
<Paragraph position="30">  A treenode is a complex data structure that contains the node's label (i.e. its syntactic category), a list of its daughters and a pointer to the f-structure attached to it.</Paragraph>
<Paragraph position="31"> The basic operations are predict, scan and complete which are close to the definition in Earley (1970). For the construction of the c-structure these actions are augmented in the following way: predict creates an empty treenode labeled with the predicted category, scan attaches the next input word as the rightmost daughter to the state's &lt;tree &gt;, and complete attaches the state's &lt;tree&gt; as the rightmost daughter to all treenodes in the states of the current state's &lt;pred.list&gt;. null For the construction of the f-structure, which is built up incrementally being used as a filter on c-structures as soon as possible (as described in Block/Hunze(1986)) the following augmentations are performed: The &lt;dot&gt; part of a state not only marks the position in the cfrule's right hand side but also contains the functional equations associated with that position. When completing and scaning the parser instantiates the upand down-arrow of the equations with virtual copies of the mother's and daughter's f-structure. The equations are then evaluated and the new f-structure associated with the up-arrow becomes the f-structure of the new state's tree.</Paragraph>
<Paragraph position="32"> The basic idea behind the treatment of long-distance phenomena is to augment the mechanism for the  contextfree skeleton of the grammar with a mechanism that transports displaced elements until they can be consumed at suitable postions. The suitability of these positions thereby is restricted by several constraints. Firstly a position only can come into account if a phrase of the same type as the moved phrase is predicted by the grammar. Secondly the mechanism for propagating the moved constituents obeys certain linguistic constraints such as bounding nodes. Thus it roughly can be viewed as a sort of linguistically constrained HOLD/VIR-mechanism that is integrated in the parser, freeing the grammar writer from the necessity of encoding the details of holding displaced elements and consuming them by VIR explicitly on the grammar level. An advantage of this approach for the handling of such phenonena is that one can do without empty productions in the cf part of grammar that tend to lead to an enormous amount of spurious phrase structure trees. On the othei&amp;quot; hand the mechanism to be presented shows some asymetry, since it only deals with long distance dependencies where the displaced element occurs in terms of parsing direction before its originating position. Since the parser presented here parses form left to right this means that we take the assumption for granted that there are no rightward long-distance movements.</Paragraph>
<Paragraph position="33"> For the treatment of movement &lt;dot&gt; is expanded to the complex data-structure of the type (&lt;syn. cat.&gt; &lt;equations&gt; &lt;slash&gt;) where &lt;slash&gt; is a flag containing information on constituents to be moved. If &lt;slash&gt; is empty no movement is performed. If &lt;slash&gt; is set the node which is associated to the &lt;dot&gt; will be moved rightward.</Paragraph>
<Paragraph position="34"> A state is augmented by three additional components, namely &lt;pending&gt; and &lt;consumed&gt; &lt;to-be-moved&gt; that are used for the bookkeeping of moved nodes.</Paragraph>
<Paragraph position="35"> &lt;pending&gt; is a pushdown stack of the nodes that are moved. Each time a node is declared in the grammar to be moved it is pushed onto the &lt;pending&gt; of the state being developed. The nodes in &lt;pending&gt; are then propagated to the subsequent paths.</Paragraph>
<Paragraph position="36"> &lt;consumed&gt; is the list of all traces consumed in a subtree. That is whenever a constituent on &lt; pending &gt; is used to satisfy the corresponding prediction of some state (i.e. being used as if it was the current element in the input at some state) it is popped from &lt;pending&gt; and pushed on &lt;consumed &gt;. Furthermore &lt;consumed&gt; is used to control the attachment of phrases to their mother nodes by the completer, allowing phrases dominated by a root node with consumed subphrases in them to be attached only if that phrase is also in &lt;pending &gt; in the mother state. &lt;to-be-moved&gt; is used to transport a displaced constituent to its corresponding root-node, where after being pushed onto &lt;pending&gt; it can be consumed as a missing constituent The snapshot of the parser's states in (9) shows the relevant subset of states induced by the attachment of anwh-NP byagrammar rule like (10) whilst parsing a sentence like the one in (8).</Paragraph>
<Paragraph position="38"> In order to see the working of our mechanism in the case of a cyclic movement a look at the following examples shows its basic features. Thus in an example like (tl) Who do you believe that he knows 1 2 3 4 the moved wh-NP is transported into the embedded sentence via landing at a S'-initial optional NP-position, from where it is moved in turn.</Paragraph>
<Paragraph position="39">  With a grammar rule like (12) - where XP/$ in our rule notation means that the phrase XP is to be moved - the wh-NP who is first moved form its matrix4entence initial position and consumed at the embedded sentences' NP-position from where it is moved again as shown in Figure 3.</Paragraph>
<Paragraph position="40"> The treatment of tile three critical components &lt;pending&gt;, &lt;consumed&gt; and &lt;to-be-moved&gt; in such a case of cyclic mow~ment is shown in the following  (* the moved wh-NP is still on &lt; consumed&gt;, waiting to be discarded when the state predicting its originating root-node category is completed) The organisation of the list of &lt;pending&gt; nodes as a pushdown-stack rather than a queue mirrors the property of long-distance movement to be nested. The parser will therefore account for the ungrammatical trace bindings in (14).</Paragraph>
<Paragraph position="41"> (14) *Which sonatai is this violinj easy to play ti on tj Though the sentence will finally be parsed, it will have, as predicted, the semantically deviant nested binding of the traces: to play the violin on which sonata. The mechanism presented so far does not cover the treatment of bounding nodes, as there are no bounding restrictions on the way how the constituents on &lt; pending &gt; are transported and/or consumed. Without imposing any further restrictions on our mechanism, it is possible to move a constituent into a subtree dominated by a bounding node.</Paragraph>
<Paragraph position="42"> To prevent this a new empty &lt;pending&gt; is used in every state that is a consequence of the prediction of a bounding node category. Thus any moved constituent which is possibly on &lt;pending&gt; at such a state of the analysis is not available during the parsing of the bounded node category dominated substructure.</Paragraph>
<Paragraph position="43"> When, however, this substructure is parsed completely and attached to its mother structure by the completer the old (i.e. the mother's state) &lt;pending &gt; is used and propagated in the subsequent states.</Paragraph>
<Paragraph position="44"> Thus in an example like (15) if at some state the bounding node category S (5) is predicted all the successive states (as for example statej) have a new empty &lt;pending&gt;.</Paragraph>
<Paragraph position="45">  (* when the bounding node category is predicted &amp;quot;what&amp;quot; is pending; it will not be propagated to those subsequent states that expand the bounding node doina ted substructure)  In our example the parser will come to state I after completing state i and finally (via some more completer operations) to state m. State m finally represents a configuration that says that (14) will not be parsed due to the fact that &lt;pending&gt; is not empty while the complete input is analysed with no predictions left. For the specification of bounding nodes in our grammar we offer three possibilities. Firstly in the spirit of LFG on a rule specific basis, secondly globally by declaring a categorya globally bounding node (which diminishes the grammar writers work on actually globally bounding nodes) and thirdly a negative specification concerning bounding features of a globally bounding node, thus admitting an simple expression of exceptions.</Paragraph>
<Paragraph position="46"> The parserpesented is implemented inlnterlisp-Dona personal Lisp workstation and has been testet with a grammar comprising a major part of the phenomena discussed in Kaplan/Bresnan's fundamental LFG-paper. The work described here is partly sponsored by the Federal Ministry of Research and Technology in the WlSBER-project.</Paragraph>
<Paragraph position="47"> We would like to express our thank to our collegues M. Gehrke and R. Hunze for their criticism and encouragement.</Paragraph>
</Section>
</Paper>

