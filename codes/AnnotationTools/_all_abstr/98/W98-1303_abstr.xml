<?xml version="1.0" standalone="yes"?>

<Paper uid="W98-1303">
<Title>Does tagging help parsing? A case study on finite state parsing</Title>
<Section position="2" start_page="0" end_page="27" type="abstr">
<SectionTitle>
1 Introduction
</SectionTitle>
<Paragraph position="0"></Paragraph>
<Section position="1" start_page="0" end_page="26" type="sub_section">
<SectionTitle>
1.1 The parsing problem
</SectionTitle>
<Paragraph position="0"> Most application-oriented natural-language parsers are computer prograTrLq that try to automatically ass~n a syntactic structure onto input sentences, by using a formal language model, e.g. a large gr~mm~. In a sense, a syntactic parser tries to choose from a multitude of imaginable syntactic sentence analyses the alternative that is the most appropriate for the input sentence. So syntactic parsing can be ~iewed as a massive disambiguation task where the main  problems are: (i) Determln~n~ the correct sentence A~lysis, especially in the case of long sentences, may require a lot of time and memory (computational problem) (ii) Deciding between possible analyses may be dlmcult due to (i) the inherent syntactic ambiguity of the sentence or (ii) the shortages in the specificity of the parser's language model (linguistic problem) (iii) Assigning a syntactic analysis to an acceptable sentence may fail because the parser's language model does not account for the syntactic structures that emerge as the sentence (linguistic problem) 1.2 A possible partial solution  A solution often proposed to these problems is use of a tagger as a front-end of the parser. Now what is a tagger, and how are they supposed to help parsers? What are taggers7 Program~ variously known as part-of-speech taggers, POS taggers or morphological taggers typically contain three analytic stages:  - The token@er identifies words, punctuation marks and sentence boundaries. - The ls~ca/ana/~/ser assigns possible analyses to each word. Some words can receive multiple analyses; for instance the sentence Those girls sing well can be analysed as follows:</Paragraph>
<Paragraph position="2"> Here Those gets two alternative analyses (a dete~,,,iner and a pronoun analysis), while tvei! gets as many as six alternative analyses.</Paragraph>
<Paragraph position="3"> - The d~sambiguator resolves lexical ambiguity by removing analyses that seem superfluous according to the language model used by the program; for instance: Those_DET girls_Npl sing_Vpres well_ADV In this case all words became fully disambiguated, but, to reduce the risk of removing the correct analysis, some of the most r\]if~cult ambiguities can optionally be left pending in many tagging program~ (so other modules e.g. the parser, can choose between them if necessary).</Paragraph>
<Paragraph position="4"> The design of the disambiguator is the hardest subproblem in tagging, and several solutions have been proposed for improving the reliability of the disambiguator's language model (data-driven models automatically generated from pretagged texts; linguistic models with manually developed disambiguation grAmmArs; hybrid models).</Paragraph>
<Paragraph position="5"> Why are taggers supposed to be useful? As for the supposed usefulness of taggers for parsing, the following assumptions are often made: (i) The tagger rapidly decreases the ambiguity of the sentence, as a consequence of which the computation~IIy heavier syntactic parser has to deal with less ambiguity. So the computa. tional problem should become smal/er and parsing faster.</Paragraph>
<Paragraph position="6"> (ii) The tagger resolves some ambiguities not addressed by the syntactic parser's language model, so the parser is expected to have a better chance to find the correct analysis with the tagger than without it.</Paragraph>
<Paragraph position="7"> At the first flush, these assumptions may seem self-evidently true. However, also sceptical views are possible. One could argue that taggers do not give any real advantage for mature syntactic parsers, e.g. for the following reasons: (i) taggers resolve mainly local, 'easy' ambiguities that would be resolved by the parser in any case with very little extra computational load, so it is questionable whether a mature syntactic parser would gain anything in terms of speed or accuracy PS~om using a tagger, (fi) taggers make so many mlspredictions that the possible galne in parsing time, or average number of syntactic parses, is more than counteracted by the decrease in the parser's recall: for many sentences no good parse is available if correct POS tags have been lost, and  (iii) even if there were a tagger with a satisfactory recall and precision, maldng it would take so much effort, either in the form of annotating big training corpora, or writing rules, that the same effort would be more beneficially spent on developing the parser itself. So the assumed relevance of tagging for parsing seems to be an open, empirical question. What does the literature say on the subject?</Paragraph>
</Section>
<Section position="2" start_page="26" end_page="26" type="sub_section">
<SectionTitle>
1.3 Earlier studies
</SectionTitle>
<Paragraph position="0"></Paragraph>
<Paragraph position="2"> The computational linguistics literature seems to contain very few evaluations about using taggers in parsing. Three studies are examined next.</Paragraph>
<Paragraph position="3"> - A well-known paper on using statistical taggers in statistical parsing is one by Charniak et ai. {1\]. In their experiments, they use two kinds of statistical tagger: the single tagger outputs fully disambiguated text, while the multiple tagger leaves the hardest ambiguities unresolved to decrease the number of its mlspredictions. Contrary to expectations, their experiments suggest that the statistical parser is no better in resolving the hardest morphological ambiguities than the single tagger, so passing the most difficult ambiguities on to the aw~ecUy more informed syntactic language model does not seem practically motivated.</Paragraph>
<Paragraph position="4"> - A paper by Wauschkuhn \[17\] e Yamlnes the use of a statistical HMM tagger for German as a front-end of a syntactic parser that uses a hand-coded grammar. The experiments suggest that a tagger reduces the ambiguity of the syntactic parser's output, but only with a considerable penalty in terms of the poorer recognition rate of the parser. The experiments give the impression that taggers, at least statistical ones, are not particularly useful for improving a parser's accuracy.</Paragraph>
<Paragraph position="5"> - Results more favourable for tagging are reported by Ofiazer and Kuru~z \[7\]. They report that a rule-based tagger of Turkish (that uses a human disambiguator as its final component) improved the speed of a LFG parser of Turkish using a non-trivial grammar by a factor of 2.38, while the average number of parses per sentence fell from 5.78 to 3.30. However, they do not report the figures for sentence recognition: how many sentences got a parse with the tagger and how many without. Also their test data was rather small: 80 sentences with an average sentence length of 5.7 words only. Several questions remain open:</Paragraph>
</Section>
<Section position="3" start_page="26" end_page="27" type="sub_section">
<SectionTitle>
1.4 Structure of this paper
</SectionTitle>
<Paragraph position="0"> In this paper, we present experiments with two taggers and one parser. The parser is a reductionistic dependency-oriented finite-state parser of English that represents utterances with morphological and syntactic tags. The parser consists of the following components: (i) a tokeniser; (ii) a morphological analyser; (iii) a simple lookup program for introducing all possible syntactic analyses as alternatives for each word and word-boundary; and (iv) a finite-state syntactic parser (actually a syntactic disambiguator) that discards those sentence readings that violate the parser's grammar.</Paragraph>
<Paragraph position="1"> This setup contains no specific module for resolving morphological ambiguities that arise in lexical analysis. The syntactic grammar actually suffices for resolving many morphological ambiguities as a side-effect of proper syntactic parsing.</Paragraph>
<Paragraph position="2">  However, a morphological disambiguator can optionally be included in the setup, directly after morphological analysis. The disambiguators referred to in this paper are linguistic constraint-based systems. Ambiguities occurring in unspecified contexts are not resolved, so these disambiguators can produce ambiguous output.</Paragraph>
<Paragraph position="3"> In this paper we report experiments where the modular setup uses the following disamhiguation modules:  - No disambiguation. Only the 6-ite state syntactic parser is used for ambiguity resolution. - A small disambiguator whose 149 rules were written during one day. This module discards over 70% of all extra morphological readings.</Paragraph>
<Paragraph position="4"> - A mature disambiguator whose 3,500 rules were written in the course of several years. This  module discards about 95% of all extra morphological readings with a ml,lmal error rate. The data is new to the system, and it consists of three corpora, each with 200 sentences. In the experiments, we consider the following issues:  - Syntactic ambiguity before finite state disambiguatio~ how is the ambiguity rate of the syntactic disambiguator's input reduced by different morphological disambiguators? - The parser's recognition rate how many sentences does the finite state parser recognise with different morphological disambiguators? - Multiple analyses: how much syntactic ambiguity is produced by the different setups? - Parsing time: how much does the use of different disambiguators affect parsing time?</Paragraph>
</Section>
</Section>
</Paper>

