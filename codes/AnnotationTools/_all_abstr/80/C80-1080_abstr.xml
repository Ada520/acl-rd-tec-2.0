<?xml version="1.0" standalone="yes"?>

<Paper uid="C80-1080">
<Title>TRANSLATING INTERACTIVE COMPUTER DIALOGUES FROM IDEOGRAPHIC TO ALPHABETIC LANGUAGES</Title>
<Section position="1" start_page="0" end_page="528" type="abstr">
<SectionTitle>
TRANSLATING INTERACTIVE COMPUTER DIALOGUES
FROM IDEOGRAPHIC TO ALPHABETIC LANGUAGES
</SectionTitle>
<Paragraph position="0"> U.K.</Paragraph>
<Paragraph position="1"> Su~rv A scheme is described which enables users to interact with a timesharing computer in an ideographic language such as Chinese. The host computer runs a completely unmodified English-based operating systemdeg the necessary translation being performed by a preprocessing microcomputer which constitutes the ideographic terminal. The two systems communicate through a serial line, and the host sees the preprocessor as an ordinary (English) terminal. Although the examples are all drawn from Chinese, the scheme could equally well serve other ideographic languages like Japanese and Korean.</Paragraph>
<Paragraph position="2"> After brief consideration of the terminal's keyboard and display, we examine the software problems of translation for six example subsystems ~ two interpreted programming languages, text editor, document preparation system, interactive database management system, and the command level of the operating system itself.</Paragraph>
<Paragraph position="3"> The investigation shows that few limitations need be placed on the user's actions. For example, a suitable transliteration to alphabetics allows ideographic filenames to be used and manipulated quite naturally by operating system commands (which are themselved transliterated). The same transliteration allows ideographic text to be entered, edited, stored, displayed, and printed without difficulty. If text to be altered is located and specified by context (as is common with most modern text editors), rather than by character offsets, the transliteration must be designed to yield unambiguous pattern matching. Existing document-preparation software can be used for ideographic text, although there is a difficulty if English and ideographics are interspersed within the same document. The most difficult subsystem to handle is the BASIC language, with its baroque syntax and non-contextual string-matching operations: however, the paper shows how suitable action by the preprocessor can overcome all problems of standard BASIC except for operations which depend explicitly on ASCII codes.</Paragraph>
<Paragraph position="4"> Recent advances in technology enable considerable improvements to be made over previous attempts to construct an ideographic terminal. 1,2 High-quality raster-based graphics systems provide an economical means of output. Hard copy can be obtained with high-resolution matrix printers 3 and laser-driven phototypesetters. 4 Character generation requires a fast read-only store for frequently-occurring ideographs, backed up by a slower store for the rest ~ this approach is encouraged by language statistics.5, 6 Furthermore, large read-only memories will soon become available which are suitable for storing picturegrams of thousands of characters. For example, at the recent International Solid-State Circuits conference in San Francisco, NTT's</Paragraph>
<Section position="1" start_page="0" end_page="528" type="sub_section">
<SectionTitle>
Musashino Electrical Communication Laboratory
</SectionTitle>
<Paragraph position="0"> announced a 4 Mbit read-only memory, arranged as two duplicate halves of 2 Mbit each to reduce the effect of single-bit errors. 7 This could accomodate up to ~000 picturegrams, each stored as a 16 x 16 dot matrix. The major computer companies in the West have no product lines which include ideographic terminals, although IBM recently introduced a Katakana VDU. 8 However, their appearance can only be a matter of time.</Paragraph>
<Paragraph position="1"> Input of ideographic text is somewhat more difficult than output. Chinese typewriters have a table-sized keyboard with 2400 ideographs, supplemented by a library of extra characters which are inserted into the machine when required. The problems of inexperienced users with such a large keyboard are exacerbated by the difficulty of finding a particular character, for ideographic languages have no simple and universally-accepted &amp;quot;alphabetic ordering&amp;quot;. Although novel keyboards and computer-based retrieval methods have been designed, 9.1 they do not appear to have met any great degree of acceptance.</Paragraph>
<Paragraph position="2"> However, a new scheme which employs 238 keys shows promise as a computer input device for Chinese ideographs. I0 The method originally covered a basic lexicon of 3260 characters, but has recently been extended to over twice this number without increasing the keyboard size. It is based on an analysis of characters into radicals, which corresponds to the way that Chinese children are taught to write in school. With 346 radicals, between I and 6 keystrokes are required for each character, the average being 2.7. (Compare this with the average of 6  alphabetic characters per English word.*) These 346 radicals are placed on the 23~ keys in such a way that although some keys correspond to two radicals, no ambiguity is created when actual Chinese words are entered because of restrictions on valid combinations of radicals. Note incidentally that this simple technique has been used in situations where alphabetic ~nglish words are keyed on a 12-key touch-tone telephone pad. 11 Taking these considerations into account, we envisage an ideographic computer terminal comprising a small microcomputer system with keyboard, display, and hardware character generator, possibly supplemented by a writeable character store which is maintained by the processor from a floppy disk holding the remaining, rarer, characters.</Paragraph>
<Paragraph position="3"> Given such a microcomputer-based ideographic terminal, it is clearly possible to write a specialized operating system and application software for it on a general-purpose timesharing system. However, the effort required is enormous, and the approach denies rapid access to new computer developments in the West. This paper explores an alternative, namely, the use of the terminal as a front-end processor for accessing English computer systems. Such a scheme is not without its disadvantages, for much data-processing depends upon an alphabetic structure of language.</Paragraph>
<Paragraph position="4"> However, we presuppose no modification whatever of the host computer software and examine the extent to which the scheme can be made to work, and what facilities must be forfeit.</Paragraph>
<Paragraph position="5"> Semiotics of interactive computer systems When users speaking other alphabetic languages, like French or German, interact with English-based computer systems, relatively few problems arise. Much interactive dialogue involves ~ text, which is not interpreted or constrained by the system at all. For example, files can be edited or used for data-base retrieval, and comments can be included in programming languages, irrespective of the particular language used m providing it is alphabetic. String decomposition by character position, as is common in older text editors, creates no problem. Syntactic constraints are placed by the system on certain signs, which we call neutral. Examples are file names and other identifiers. However, there is no reason to ~Of course, the information in a single keystroke is much higher in the Chinese case. Using a naive zero-order approximation which does not take into account character or radical frequencies, the entropy of a keystroke is 6.4 bits, while for English with a 27-key board it is only 4.8 bits. Multiplying these by the mean lengths we obtain surprisingly similar figures of 23 bits/ideographs for Chinese and 28 bits/word for English.</Paragraph>
<Paragraph position="6"> believe that this causes any more difficulty in other alphabetic language~ than it does in English. Symbols for constructs which have semantic import in the system, like keywords in programming languages and operating system commands, constitute active signs which must agree exactly with the representation stored internally in the computer system. Often, foreign users are content to write keywords in English, because of its predominance in the computer world B international computer language standards usually use English, most programming-language primers are written in English, and so on. However, altering the keyword representations stored in the computer system is not a difficult task, at least in theory: they will appear as character strings in the source code and editing and recompiling it is all that is necessary. Hence the issue of language-translation preprocessors which is tackled in this paper does not arise for alphabetic-language users.</Paragraph>
<Paragraph position="7"> With ideographs, the situation is not so simple. Certainly an ideographic computer terminal could interface to a standard serial line, emitting ASCII code sequences which represent ideographs and accepting them to generate an ideograph on the screen. Then the operating system tables which store keywords internally could be adjusted to hold the ASCII sequences which represent the particular ideographs used as keywords. Although this copes correctly with active signs, difficulties would still arise with passive and neutral ones. For example, string editing based on character positions would fail, unless the user was keenly aware of the internal representation of ideographs. It would be difficult to accomodate the syntactic constraints for neutral signs.</Paragraph>
<Paragraph position="8"> BASIC identifiers, for example, must contain at most two characters, the first being a letter and the second, if any, a digit. Resolution of these problems requires a more radical modification of the system software than simply altering tables. Another, simpler, alternative is to leave the system unchanged and to try to incorporate the necessary intelligence in a preprocessor.</Paragraph>
<Paragraph position="9"> The kind of signs that must be dealt with, then, are as follows.</Paragraph>
<Paragraph position="10"> e * These constitute text that is not interpreted by the system. Certain special characters, which are interpreted at device driver level ~ like interrupt signals, rubouts, and line-erase characters ~ must not appear by accident in the passive text. The possibility of editing by character offset must be noted.</Paragraph>
<Paragraph position="11"> These symbols must conform to syntactic constraints imposed by the system. Examples are filenames identifiers in programming languages.</Paragraph>
<Paragraph position="12"> Most systems insist that neutral symbols contain only ~n~ characters (and not control  characters), and in many cases only alphabetics and numerals are allowed (ie not &amp;quot;/&amp;quot;, &amp;quot;I&amp;quot;, etc.). Certain characters sometimes have special meaning in certain contexts. For example, many operating systems allow wild-card specification in filenames, either of a single character (often indicated by &amp;quot;?&amp;quot;) or a string of characters (by &amp;quot;*&amp;quot;). Programming languages usually prohibit identifiers beginning with a digit, and some (eg BASIC) restrict their length to two characters.</Paragraph>
<Paragraph position="13"> These symbols must agree exactly with internally-stored keywords. Hence they must be translated by the preprocessor, if operatingsystem modifications are forsworn.</Paragraph>
<Paragraph position="14"> One serious difficulty arises when text is entered in one mode and subsequently used in another. This happens, for example, when a command file is entered using the editor (as passive text) and is subsequently interpreted by another subsystem which normally accepts input from the keyboard. The keyboard input typically contains a mixture of active, neutral, and passive text (say keywords, filenames, and comments), and whenever a subsystem is being entered the preprocessor must obviously ensure that these elements are converted appropriately. However, when a previously-entered text file is used for input, the conversion cannot be done by the preprocessor because m when the file was entered originally, the preprocessor could not know that it was destined for use by the particular subsystem as a command file, and m when the subsystem reads the command file, its contents do not pass through the preprocessor and so there is no opportunity for conversion.</Paragraph>
<Paragraph position="15"> For a more concrete example, consider interacting with the BASIC language subsystem via an ideographic preprocessor. BASIC keywords are typed as ideographs, and converted by the preprocessor to English ~ PRINT, IF, GOTO, etc.. Furthermore, BASIC identifiers are also typed as ideographs, and must be converted to BASIC variable names ~ A0, AI, A2, etc. --but let us ignore this at present. The preprocessor must maintain tables to effect the conversion. Now if the BASIC program is SAVEd, what should the resulting computer file look like? If it is to be reLOADed by the BASIC subsystem, the keywords in the program should be in English form, so that they are recognized by BASIC on reloading. If, however, it is destined to be printed on a lineprinter by a standard system utility, it should have been SAVEd as text, with keywords represented as the passive encoding of the ideographs which were typed originally.</Paragraph>
<Paragraph position="16"> For the preprocessor to work transparently, it must invoke mode-conversion programs automatically whenever the user issues certain commands (like SAVE a BASIC program). The virtue of our semiotic classification into passive, neutral, and active signs is that it allows us to see clearly the need for this.</Paragraph>
<Paragraph position="17"> For an ideographic terminal to interact with English computer systems, all ideographs must be converted to English pseudonyms. It is possible to identify several desirable properties that the translation should have.</Paragraph>
<Paragraph position="18"> The requirements for passive text are: I. An ideograph's English pseudonym should be as short as possible, for the sake of storage economy on the host computer.</Paragraph>
<Paragraph position="19"> 2. The translation should be fixed-length, so that every ideograph is represented by the same number of ASCII characters.</Paragraph>
<Paragraph position="20"> Requirement 2 will assist in string decomposition by character offset, for then only a fixed scale factor is needed to translate from an ideographic offset to the equivalent one on the host computer. It also simplifies the problem of document preparation, for a fixed-length representation means that existing software for line splitting and Justification will work on ideographic text. However, it rules out the rather attractive proposition of directly encoding the radicals forming a character.</Paragraph>
<Paragraph position="21"> 3. Given two strings of ideographs, it should be possible to tell from the translations if one is a substring of the other without false matches being caused by incorrect alignment.</Paragraph>
<Paragraph position="22"> This allows matching by context, as used in most editor programs.</Paragraph>
<Paragraph position="23"> 4. True English should never masquerade as translated ideographs.</Paragraph>
<Paragraph position="24"> It will often be necessary to mix English and ideographic text. For example, programmers may wish to use some English variable names, for mathematical symbols like x, y, sin, and cos are used in their Western form in most Chinese mathematics. Clearly, requirement 4 can never be fully satisfied, for any sequence of ASCII characters can be entered directly if desired. However, we wish to minimize the likelihood that the kind of text normally entered will masquerade as translated ideographs. It would seem sensible to include a little-used control character to flag each translated ideograph, but we will see below that this introduces difficulties. *  For neutral text, requirement I has even more force, for filenames and identifiers are usually heavily restricted in length. Clearly, in the case of BASIC identifiers no universal ideographic encoding will suffice, for only 26 + 26wi0 = 286 different combinations are allowed, and this is far less than the number of ideographs. Leaving aside this special case, which must be treated as an exception by the preprocessor, neutral text presents another requirement: 5. Translations of ideographic strings should not violate any restrictions that the host computer places on filenames, and should conform with the syntax of variable names in as many programming languages as possible.</Paragraph>
<Paragraph position="25"> additional advantage of satisfying the syntax of variable names for most computer languages (except BASIC, and upper-case-only languages). Requirement (6) indicates that the code should be based on the address of the picturegram for the ideograph in the preprocessor, so that although translation from the ideograph keystrokes to the pseudonym may be slow (Uecause a table of radicals, which may reside on backing store, must be consulted), reconstruction of an ideograph from its translation requires access to the character generator only.</Paragraph>
<Paragraph position="26"> Translatin~ interactive languages This requirement is rather stringent, because for most systems it rules out all characters except letters and digits. Furthermore, the fact that most languages prohibit identifiers which begin with a digit means that we cannot use the standard 4-digit telecode,* as employed, for example, in some standard character indices. 12 However, we will present a simple coding scheme which can reDresent 27.000 ideographs as three-character strings, with the characters chosen from the digits and upper- and lower-case alphabetics. This allows two ideographs to serve as a 6-character filename, provided that the host distinguishes upper- and lower-case characters.</Paragraph>
<Paragraph position="27"> Another requirement is 6. Although the translation from ideographs to English may be slow (because ideographic text is entered slowly on the keyboard), its inverse should be fast so that the host's output can be displayed on the terminal quickly.</Paragraph>
<Paragraph position="28"> Requirement 3 implies the use of a delimiter to ensure correct alignment of ideograph boundaries when English translations are matched. This is difficult to accomodate within a three-character translation, since with one reserved for the delimiter insufficient combinations of alphabetics and digits exist.</Paragraph>
<Paragraph position="29"> To solve this, more than one character is employed as a delimiter. With N possible characters out of which n are reserved for delimiters, n(N-n) 2 different triples exist.</Paragraph>
<Paragraph position="30"> Examination of this function, where N has value 62 (26+26+10), shows that the obvious choice of a single delimiter gives a paltry 3,700 combinations compared with the maximum of 35,300 when n = N/3. We choose an easily-recognizable encoding with a digit in one fixed position and alphabetics filling the other two. This gives 27,000 combinations. To minimize the likelihood of mistaking genuine English for ideographic translations, the digit occupies the central position, flanked by alphabetics. This has the *A brief account of the fascinating history of telecodes is given in reference 2.</Paragraph>
<Paragraph position="31"> As a prelude to our examination of the translation process for BASIC, the most commonly-used interactive language, let us consider a simpler, although somewhat more esoteric, interpreted language m LISp.13 k~ The fundamental entity in LISP is an atQ~. and is represented by a string of up to 30 letters and digits. The indivisibility of atoms, the generous maximum character length, and the starkness of the LISP syntax make translating an ideographic version an easy proposition. All names in LISP are atoms, including functions and the built-in functions which comprise the LISP system itself. Atoms are combined into lists using a handful of special characters like parentheses, full stops, and quotation marks.</Paragraph>
<Paragraph position="32"> These special characters are all commonly used in Chinese text, and so there is no need to translate them.</Paragraph>
<Paragraph position="33"> An ideographic LISP preprocessor must translate each ideograph into a unique sequence of English characters as described above.</Paragraph>
<Paragraph position="34"> Translations of the system-defined atoms, of which there are somewhat over 100, need to be stored in a table in the preprocessor with their English equivalents, so that they are converted into the correct character strings, With the encoding developed in the previous section, 30-1etter atoms permit up to 10 ideographs to be concatenated to make a name, and this should be quite sufficient to allow mnemonic identifiers to be used. The only problems with the scheme are the atom decomposition functions EXPLODE and IMPLODE, which do not appear in &amp;quot;pure&amp;quot; LISP but are often provided in specific implementations to break an atom into its constituent characters and reform it. They must be handled by writing special ideographic EXPLODE and IMPLODE functions, which take into account the structure of the codes and use the primitive EXPLODE and IMPLODE to decompose an atom into 3-character pieces.</Paragraph>
<Paragraph position="35"> Digits and operator symbols will need to have their single-character representation, and the new atomic decomposition functions should distinguish genuine ideograph translations from ordinary text, using 3-character decomposition  --529-for the first and single characters for the second.</Paragraph>
</Section>
</Section>
</Paper>

