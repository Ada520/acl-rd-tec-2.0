<?xml version="1.0" standalone="yes"?>

<Paper uid="C00-2166">
<Title>Robust Semantic Construction</Title>
<Section position="2" start_page="0" end_page="1101" type="abstr">
<SectionTitle>
1 Introduction
</SectionTitle>
<Paragraph position="0"> Recent years have seen a surge ill interest f~r robust fiat analysis, i.e. NLP systems with fairly limited supl)ly of linguistic knowledge but with vast coverage. The paper describes a module that serves as a back-end to such fiat analysis methods and transforms their output into full semantic representations as constructed by deep analysis methods. In particular, the module has been designed so as to process input fl'om  The semantic representations which the module constructs m'e so-called Verbmobil Inter~&amp;ce \[\[~Ol'lllS (\\[Irl~s) (BOS et al., 1998), (l)uilding on Reyle's Underspecified Discourse R,epresentation Structures (1993), see an example, in Figure 1). Although in principle othe, r representations could be constructed as well, VITs seem to be a particularly good choice: They Call 1oe implemented as sets of coustraints so that semantic construction (SC) reduces to collecting the constraints and unifying some variables in these constraints. Furthermore VITs are supported by ml abstract data type (Dorlla, 2000).</Paragraph>
<Paragraph position="1"> Several daunting prol)lems had to be t'aced in tile design of the module.</Paragraph>
<Paragraph position="2"> * This work was fimded by the German Federal Ministry of Education, Science, Research and Technology (BMBF) in the ti'amework of the Verbmobil Project under Grant 01 IV 1(}1 U. Many thanks are duc to M. Emele and the colleagues in Verbmobil.</Paragraph>
<Paragraph position="4"> into idle next u,e, ek.</Paragraph>
<Paragraph position="5"> Context-Free Input. The tree banks providing tile input structures (which have been built in the Verbmobil project) only encode context-free trees to facilitate the training of a statistical parser. This means that non-local dependencies are either left out (e.g. topicalization in English) or treated by flattening out sub-trees into rules (e.g. head-movenmnt ill German). The latter strategy can create a vast amount of rules: Sin(:e Gelunan head-nmvement connects a clause-initial and a clause-final position, every clause frame gives rise to a new rule. To thee this challenge some adjustments had to  be made: (1) Predicate-argument structure is indispensable for SC but presupposes reconstruction of long distance dependencies (&amp;quot;movement&amp;quot;). If syntax cmmot supl)ly it, SC has to retrieve it; on its own (see Section 5.2).</Paragraph>
<Paragraph position="6"> (2) The sheer bulk of rules prohibits manual tag: ging of syntactic rules with semantic rules. In null stead, syntax has to provide pertinent information in its rules so that SC can determiim the semantic operations required.</Paragraph>
<Paragraph position="7"> Robustness. Since the tree banks have been constructed by hand, errors are prone to crop Ul). Likewise, flat analysis methods cannot be expected to deliver input of the same quality as deep traditional parsers. Finally, grammars and semantic formalism will often difl'er in their subcategorization assmnptions: The verb move e.g. subcategorizes for hito in the tree bank (see Figure 2) but not in tile VIT tbnnalism (see Figure 3).</Paragraph>
<Paragraph position="8"> To handle this problem, the syntax-semantics-interface should be dismantled as far as possible: Only the most indispensable information should be taken over fl'om syntax. By neglecting all tile rest the system stands a good chance of skipping syntax errors. Furthermore in many cases decisions made ill syntax need to be overturned in semantics (e.g. the complement/adjunct specifications), hnportant semantic information is often deterlnined only in SC or in subsequent disambiguation lnodules that have access to larger stores of context. This approach eases the burden on syntactic analysis and potentially yields more reliable results.</Paragraph>
<Paragraph position="9"> Diverse Input. A SC module should be able to handle input from a variety of grammars and convert it into an independellt tbrmat of semantic representation. Thus, a common syntax-semantics-interface (or inore precisely an interface between syntax and SC) must be defined onto which every type of' input is mapped.</Paragraph>
</Section>
</Paper>

