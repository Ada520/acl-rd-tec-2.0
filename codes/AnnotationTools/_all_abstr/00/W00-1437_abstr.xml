<?xml version="1.0" standalone="yes"?>

<Paper uid="W00-1437">
<Title>YAG : A Template-Based Generator for Real-Time Systems*</Title>
<Section position="2" start_page="0" end_page="266" type="abstr">
<SectionTitle>
1 Introduction
YAG (Yet Another Generator) is a real-time,
</SectionTitle>
<Paragraph position="0"> general-purpose, template-based generation system that will enable interactive applications to adapt natural language output to the interactive context without requiring developers to write all possible output strings ahead of time or to embed extensive knowledge of the grammar of the target language in the application. Currently, designers of interactive systems who might wish to include dynamically generated text face a number of barriers; for example designers must decide (1) How hard will it be to link the application to the generator? (2) Will the generator be fast enough? (3) How much linguistic information will the application need to provide in order to get reasonable quality output? (5) How much effort will be required to write a generation grammar that covers all the potential outputs of the application? The design and implementation of YAG is intended to address each of these concerns.</Paragraph>
<Paragraph position="1"> In particular, YAG offers the following benefits to applications and application designers: Support for Underspecified Inputs YAG supports knowledge-based systems by accepting two types of inputs: applications can either provide a feature structure (a set of feature-value pairs) or provide a syntactically under-specified semantic structure that YAG will map onto a feature-based representation for realization. YAG also provides an opportunity for an application to add syntactic constraints, such as whether to express a proposition as a question rather than a statement, as a noun-phrase rather than as a sentence, or as a pronoun rather than a full noun phrase.</Paragraph>
<Paragraph position="2"> Speed YAG has been designed to work in realtime. The YAG ten,plate processing engine does not use search to realize text. thus the speed of generation depends oi1 the complexity of the template that the application selects. degThis work ha~s been supported by the National Science Foundation, under grants, I RI-97016 l 7 and ,,I,RI=9523666, and by lntel Corporation.</Paragraph>
<Paragraph position="3"> not on the size of the grammar. Short, simple utterances are always realized faster than longer ones. (In many other approaches, speed is a function of the grammar size, because it is searched during realization (Elhadad, 1992; Elhadad, 1993; Mann, 1983; McKeown, 1982; McKeown, 1985).) Robustness In YAG, the realization of a template cannot fail. Even if there are inconsistencies in its input (such as subject-verb disagreement), the generator will produce an understandable (if not grammatical) output. Applications that need to enforce grammaticality can use the YAG preprocessor to detect missing or conflicting features and to supply acceptable values. The preprocessor makes use of a declarative specification of slot constraints, based on an attribute grammar (Channarukul et al., 2000).</Paragraph>
<Paragraph position="4"> This specification is modifiable and extensible by the application designer.</Paragraph>
<Paragraph position="5"> Expressiveness YAG offers an expressive language for specifying a generation grammar. This language can express units as small as a word o1&amp;quot; as large as a document equally well. Unlike the typical template-based approach, the valu(~s used to instantiate slots are not limited to simple strings, but can include a variety of structures, including conditional expressions oi references to other templates. (This paper will include a more detailed discussion in the next section.) Any declarative grammar, such as one based oll feature structures, would be expressible in YAG.</Paragraph>
<Paragraph position="6"> Coverage The coverage of YAG depends oil the number of templates that have been defined in its specification language. In theory, any sentence may be realized given an appropriate template. In practice, an application builder must be concerned with whether it is possible to re-use existing templates or whether it is necessary to create new ones. YAG simplifies the task of specifying a generation grammar in several ways:  e It provides an expressive, declarative language for specifying templates. This language supports template re-use by allowing template slots to be filled by other templates. null o It includes a general-purpose, template-based grammar for a core fragment of En-The Condition rule is similar to the cond statement in LISP, returning a result when one of its antecedent conditions is true.</Paragraph>
<Paragraph position="7"> The Insertion rule returns the result of interleaving the results of two template rules.</Paragraph>
<Paragraph position="8"> The Alternation rule selects one alternative glish. These templates ;include .default values for many of the * slots, so an application may omit a feature if it has no information about it. Currently, the YAG distribution includes about 30 domain-independent syntactic templates, along with some semantic templates.</Paragraph>
<Paragraph position="9"> o It offers a tool for helping people edit templates and see what text would be realized from a template, given a set of values for its slots.</Paragraph>
<Paragraph position="10"> YAG itself comes in two versions, one in CLISP, one in JAVA, both of which run on a wide variety of platforms, including Unix and Windows 95/98.</Paragraph>
<Paragraph position="11"> In the remainder of this paper, we will describe YAG's template specification language, and some examples that illustrate the use of YAG from an application. More details can be found in (Channarukul, 1999).</Paragraph>
<Paragraph position="13"> A template is a pre-defined form with parameters that are specified by either the user or the application at run-time. In YAG, each template is composed of two main parts: template slots and template rules. Template slots are parameters or variables that applications or users can fill with values.</Paragraph>
<Paragraph position="14"> Template rules express how to realize a surface constituent. Templates are realized as strings by replacing slots in each rule with values from the application and then evaluating the rule. YAG template rules support nested and recursive templates. There are ten types of template rules.</Paragraph>
<Paragraph position="15"> The String rule returns a pre-defined string as a result.</Paragraph>
<Paragraph position="16"> The Evaluation rule evaluates the value of a reinplate slot* If the value of the slot is another feature structure, then that structure is evaluated recursively. If the value of the specified slot is not a feature structure, this rule returns the value without any further processing.</Paragraph>
<Paragraph position="17"> The Template rule returns the result of instantiating a template with a given set of slot-vahle * pairs.</Paragraph>
<Paragraph position="18"> The If rule is similar to an (f-then statement in most prograanming_languages, returning a result when {he antecedent of the rule is true.</Paragraph>
<Paragraph position="19"> template rule to be realized based on a uniform prob'ability-dis~ri-bution~-t hereby adding variety into a generated text.</Paragraph>
<Paragraph position="20"> The Punctuation rule concatenates a punctuation mark to the specified end of adjacent strings. The position of a punctuation mark is either left, right, or both.</Paragraph>
<Paragraph position="21"> The Concatenation rule appends the the result of one template rule with the results of a second rule.</Paragraph>
<Paragraph position="22"> The Word rule is used in association with pre-defined functions and a lexicon to realize expressions that should not be &amp;quot;hard-coded&amp;quot; in a template, such as the inflected forms of a word from the dictionary or the cardinal/ordinal number corresponding to an integer.</Paragraph>
<Paragraph position="23"> Figure 1 shows the template rules that would be used to express propositions of the form has-property(agent, pname, pval), such as has-property(John, age, 20), which corresponds to John's age is 20). These rules are part of  the 0BJECT-PROPERTY semantic template. The rules use the template slots agent, pname, pval, and property and the template rule types IF, CONCAT, S, TEMPLATE, COND, EVAL, and PUNC. If agent = &amp;quot;John&amp;quot;, pname = &amp;quot;age&amp;quot;, and pval = &amp;quot;20&amp;quot;, the surface text will be &amp;quot;John's age is 20.&amp;quot;  YAG provides facilities for generation from two types of inputs, a feature structure or a knowledge representation. The latter is accomplished by the use of a knowledge representation specific component that must be defined for the particular knowledge representation language to be used.</Paragraph>
<Section position="1" start_page="265" end_page="265" type="sub_section">
<SectionTitle>
3.1 Generation from a Knowledge
Representation Structure
</SectionTitle>
<Paragraph position="0"> Example 1, shows a knowledge representation input to YAG. ~ It contains two propositions and a list of control features. In this representation, M2 is the proposition that the discourse entity B2 is a member of class &amp;quot;dog&amp;quot;. M5 is the proposition that the name of the discourse entity B2 is &amp;quot;Pluto&amp;quot;. Thus, we can read the whole proposition as &amp;quot;Pluto is a member of class dog.&amp;quot; or simply &amp;quot;Pluto is a dog. &amp;quot;. The control features state that the output should be generated as a declarative sentence with &amp;quot;be&amp;quot; as the main verb. Example 1 Pluto is a dog.</Paragraph>
<Paragraph position="2"> \Vhen processing this input, YAG treats the first proposition as the primary proposition to be realized. YAG will map the MEMBER-CLASS proposition to the template shown in Figure 2.</Paragraph>
<Paragraph position="3"> The control features, form = decl and attitude = be, are also used in selecting the template. (If the form had been interrogative, a template for generating a yes-no question would have been used.) Example 2 shows an example where prominalization is specified as part of the control features. The primary proposition says that the agent (B4) is doing the action &amp;quot;take&amp;quot; on the object (B6). This proposition. along with the selected control features (form IThe knowledge representatimr language used in these examples follows the definition of SNePS case frames described in (Shapiro et al., 1996). SNePS is a semantic network processing system (Shapiro and Rapaport, 1992). llowever, inputs to YAG are parenthesized lists of symbols,, not SNePS data strllCl tires.</Paragraph>
<Paragraph position="5"> = decl and attitude = action), allows YAG to select the clause template.</Paragraph>
<Paragraph position="6">  To override the gender default (NEUTRAL) of B4 and generate &amp;quot;He&amp;quot; instead of &amp;quot;It&amp;quot;, Example 2 specifies B4's gender as MASCULINE. To override tile default expression type (full noun phrase) for both B4 and B6, Example 2 specifies (pronominal YES (B6 B4)) which forces pronominalization.</Paragraph>
</Section>
<Section position="2" start_page="265" end_page="266" type="sub_section">
<SectionTitle>
3.2 Generation from a Feature Structure
</SectionTitle>
<Paragraph position="0"> Example 3 shows a complete feature structure that would be used to realize the text &amp;quot;Blood pressure involves your heart and blood vessels.&amp;quot;. Within a feature structure, the name of the template that YAG should use is given by the template feature. Thus, in this example, YAG retrieves the clause template 2 which is shown in Figure 3.</Paragraph>
<Paragraph position="1"> In the clause template, the agent slot is bound to &amp;quot;blood pressure&amp;quot; since its value is another feature structure representing the noun-phrase ten&gt; plate. The Evaluation rule then realizes it as &amp;quot;blood pressure&amp;quot;. The Template rule realizes the verb &amp;quot;involves&amp;quot;, by evaluating the verb-form template with the process value taken from the clause template.</Paragraph>
<Paragraph position="2"> The other slots (which woukt normally be taken from</Paragraph>
</Section>
</Section>
</Paper>

