<?xml version="1.0" standalone="yes"?>

<Paper uid="E95-1019">
<Title>and Deidre Wheeler (eds.) Categorial Grammars</Title>
<Section position="1" start_page="0" end_page="134" type="abstr">
<SectionTitle>
Abstract
</SectionTitle>
<Paragraph position="0"> We show how categorial deduction can be implemented in higher-order (linear) logic programming, thereby realising parsing as deduction for the associative and non-associative Lambek calculi. This provides a method of solution to the parsing problem of Lambek categorial grammar applicable to a variety of its extensions.</Paragraph>
<Paragraph position="1"> The present work deals with the parsing problem for Lambek calculus and its extensions as developed in, for example, Moortgat (1988), van Benthem (1991), Moortgat and Morrill (1991), Moortgat and Oehrle (1993), Morrill (1994b) and Hepple (1995). Some previous approaches to parsing Lambek grammar such as KSnig (1989), Heppie (1990) and Hendriks (1993) have concentrated on the possibilities of sequent proof normalisation. In P~oorda (1991), Moortgat (1992), Headriks (1993) and Oehrle (1994) a strategy of unfolding and labelling for proof net construction is considered. We aim to show here how such unfolding allows compilation into programs executable by a version of SLD resolution, implementing categorial deduction in dynamic linear clauses. The linearity resides in the use exactly once per word token of each of the clauses compiled from lexical categorisations. By dynamic, it is meant that clauses may be higher-order (they are hereditary Harrop Horn clauses) so that clausal resolution involves insertion in, as well as retraction from, the resolution database; see Miller et al. (1991), and Hodas and Miller (1994).</Paragraph>
<Paragraph position="2"> It is shown how a range of calculi can be treated by dealing with the highest common factor of connectives as linear logical validity. The prosodic (i.e. sublinear) aspects of word order and hierarchical structure are encoded in labels, in effect the term structure of quantified linear logic. Compiling labels according to interpretations in groupoids provides a general method for calculi with various structural properties and also for multimodal hybrid formulations. Unification must be carried out according to the structural axioms but is limited to one-way matching, i.e.</Paragraph>
<Paragraph position="3"> one term is always ground. Furthermore, for the particular case of associative Lambek calculus an additional perspective of binary relational interpretation allows an especially efficient coding in which the span of expressions is represented in such a way as to avoid the computation of unifiers under associativity, and this can also be exploited for non-associative calculus.</Paragraph>
<Paragraph position="4"> Higher-order linear logic programming has already been applied to natural language processing in, for example, Hodas (1992) and Hodas and Miller (1994), in work deriving from Pareschi (1989) and Pareschi and Miller (1990). What we show here is that such implementation can be realised systematically, indeed by a mechanical compilation, while grammars themselves are written in higher level categorial grammar formalism.</Paragraph>
<Paragraph position="5"> Automated deduction for Lambek calculi is of interest in its own right but solution of the parsing problem for categorial logic allowing significant linguistic coverage demands automated deduction for more than just individual calculi. There is a need for methods applying to whole classes of systems in ways which are principled and powerful enough to support the further generalisations that grammar development will demand. We aim to indicate here how higher-order logic programruing can provide for such a need.</Paragraph>
<Paragraph position="6"> After reviewing the &amp;quot;standard&amp;quot; approach, via sequent proof normalisation, we outline the relevant features of (linear) logic programming and explain compilation and execution for associative and non-associative calculi in terms of groupoid and binary relational interpretations of categorial connectives. We go on to briefly mention multi-modal calculi for the binary connectives.</Paragraph>
<Paragraph position="7"> The parsing problem is usually construed as the recovery of structural descriptions assigned to strings by a grammar. In practice the interest is in computing semantic forms implicit in the structural descriptions, which are themselves usually implicit in the history of a derivation recognising well-formedness of a string. This is true in particular of compositional categorial architec- null tures and we shall focus on algorithms for showing well-formedness. The further step to computing semantics is unproblematic.</Paragraph>
<Paragraph position="8"> For the non-associative Lambek calculus NL of Lambek (1961) we assume types freely generated from a set of primitive types by binary (infix) operators \, / and o. A sequent comprises a succedent type A and an antecedent configuration r which is a binary bracketed list of one or more types; we write F ::~ A. The notation F(A) here refers to a configuration I&amp;quot; with a distinguished  subconfiguration A.</Paragraph>
<Paragraph position="9"> a. A =~ a id F =~ A A(A) =,. B (1) ,Cut ~(r) ~ B b. F =~ A A(B) =~ C \[A, r\] ~ B \L \R z~(\[r, A\B\]) ~ c r =~ A\B c. F =~ A A(B) ~ C \[r, A\] ~ B ./L ./R &amp;(\[B/A, r\]) ~ c r =* B/A d. r(\[A, B\]) C r = A a B oL oR F(A.B) ~ C r, .A :, AoB  For the associative Lambek calculus L of Lambek (1958) the types are the same. A sequent comprises a succedent type A and an antecedent configuration F which is a list of one or more types; again we write F =~ A.</Paragraph>
<Paragraph position="11"> Lambek showed Cut-elimination for both calculi, i.e. every theorem has a Cut-free proof. Of the remaining rules each instance of premises has exactly one connective occurrence less than the corresponding conclusion so Cut-elimination shows decidability through finite space Cut-free sequent proof search from conclusions to premises. Lifting is derivable in NL as follows:  It is also derivable in L; indeed all NL derivations are converted to L derivations by simply erasing the brackets. But L-derivable composition depends essentially on associativity and is not  Even amongst the Cut-free proofs however there is still semantic equivalence under the Curry-Howard rendering (van Benthem, 1983; see Morrill, 1994b) and in this respect redundancy in parsing as exhaustive proof search since distinct lines of inference converge on common subproblems. This derivational equivalence (or: &amp;quot;spurious ambiguity&amp;quot;) betrays the permutability of certain rule applications. Thus two left rules may be permutable: N/CN, CN, N\S :=~ S can be proved by choosing to work on either connective first.</Paragraph>
<Paragraph position="12"> And left and right rules are permutable: N/CN, CN =:~ S/(N\S)) may be proved by applying a left rule first, or a right rule, (and the latter step then further admits the two options of the first example). Such non-determinism is not significant semantically: the variants ha:ve the same readings; the non-determinism in partitioning by the binary left rules in L is semantically significant, but still a source of inefficiency in its backward chaining &amp;quot;generate-and-test&amp;quot; incarnation. Another source of derivational equivalence is that a complex id axiom instance such as N\S =:~ N\S can be proved either by a direct matching against the axiom scheme, or by two rule applications. This is easily solved by restricting id to atomic formulas. More problematic are the permutability of rule applications, the non-determinism of rules requiring splitting of configurations in L, and the need in NL to hypothesise configuration structure a priori (such hierarchical structure is not given by the input to the parsing problem). It seems that only the first of these difficulties can be overcome from a Gentzen sequent perspective.</Paragraph>
<Paragraph position="13"> The situation regarding equivalence and rule ordering is solved, at least for L-{*L}, by sequent proof normalisation (KSnig, 1989; Hepple, 1990; Hendriks, 1993):  a. \[-)-7 =*&amp;quot; A id* r,,\[-Y\],r~ ~ o (s) rl,A,r \[-B-\] p&amp;quot; A(r,~-~)~c \L&amp;quot; r~\R c. r=~r ~ A(~-\])=~C r,A=~\[B\], R  This involves firstly ordering right rules before left rules reading from endsequent to axiom leaves  (so left rules only apply to sequents with atomic succedents; this effects uniform proof; see Miller et al., 1991), and secondly further demanding successive unfolding of the same configuration type (&amp;quot;focusing&amp;quot;). In the *-ed rules the succedent is atomic. A necessary condition for success is that an antecedent type is only selected by P* if it yields the succedent atom as its eventual range. Let us refer to (5) as \[-L-\]. \[~\] is free of spurious ambiguity, and I-r. F ::~ A iff I-\[-~ F ::~ I-A-\]. The focusing strategy breaks down t.....-I for .L: (VP/PP)/N, N.PP =~ VP requires switching between configuration types. It happens that left occurrences of product are not motivated in grammar, but more critically sequent proof normalisation leaves the non-determinism of partitioning, and offers no general method for multi-modal extensions which may have complex and interacting structural properties. To eliminate the splitting problem we need some kind of representation of configurations such that the domain of functors need not be hypothesised and then checked, but rather discovered by constraint propagation. Such is the character of our trea.tment, whereby partitioning is explored by unification in the term structure of higher-order linear logic piogramming, to which we now turn. By way of orientation we review the (propositional) features of clausal programming.</Paragraph>
<Paragraph position="14"> The first order case, naturally, corresponds to Prolog. Let us assume a set ATO./t4 of atomic formulas, 0-ary, 1-ary, etc., formula constructors  {' A... A &amp;quot;}hE{O,1,.,,} and a binary (infix) formula constructor ,--. A sequent comprises an agenda forlnula A and a database F which is a bag of program clauses {B1,..., B,}m,n &gt; 0 (subscript m for multiset); we write F =:~ A. In BNF, the set of agendas corresponding to the nonterminal AGPS.AfT)A and the set of program clauses corresponding to the nonterminal T'CPSS are defined by:</Paragraph>
<Paragraph position="16"> For first order programlning the set CjO.APS of goals is defined by:</Paragraph>
<Paragraph position="18"> I.e. the unit agenda is a consequence of any database containing its atomic clause.</Paragraph>
<Paragraph position="19"> F,A ~ B1 A...ABn =C/&amp;quot; B1 A . . . A BnA (9) C~ A...A Cm .RES F,A ,--- B1 A...AB, ~ AAC1 A... ACre I.e. we can resolve the first goal on the agenda with the head of a program clause and then continue with the program as before and a new agenda given by prefixing the program clause subagenda to the rest of the original agenda (depth-first search).</Paragraph>
<Paragraph position="20"> For the higher-order case agendas and program clauses are defined as above, but the notion of GOAPS on which they depend is generalised to include implications:</Paragraph>
</Section>
</Paper>

