<?xml version="1.0" standalone="yes"?>

<Paper uid="J81-3002">
<Title>Translating Spanish into Logic through Logic</Title>
<Section position="2" start_page="0" end_page="0" type="abstr">
<SectionTitle>
1. Introduction
</SectionTitle>
<Paragraph position="0"> The idea of using logic as a conceptual framework in question-answering systems is not new. The fact that it can formally deal with the notion of logical consequence makes it particularly attractive for representing meaning. Standard predicate calculus, however, does not seem adequate for representing all the semantic features of natural language (NL), e.g. presuppositions and the subtleties of meaning involved in NL quantifiers. Nevertheless, some recent developments indicate that logic can play an important role in NL processing.</Paragraph>
<Paragraph position="1"> In the first place, recent linguistic research \[15,18\] has arrived at interesting results concerning the extension of standard predicate calculus in order to provide a better formal model of language.</Paragraph>
<Paragraph position="2"> Secondly, programming in logic \[19,29\] has become possible since the development of the PROLOG programming language at Marseille \[3,5,27\]. Logic can now be used both as the underlying formalism and as the programming tool. As has been shown in \[30\], no loss in efficiency need be involved with respect to languages such as LISP, even though higher level features are supported in PROLOG (e.g. non-determinism). null Thirdly, most PROLOG implementations include a version of metamorphosis grammars (MGs), a logic-based formalism useful in particular for describing NL processors in terms of very powerful rewriting rules \[5\].</Paragraph>
<Paragraph position="3"> Finally, the evolution in data base technology has been tending more and more towards the use of logic, both for data description and for queries \[14\].</Paragraph>
<Paragraph position="4"> Drawing on these developments, we have implemented (starting in 1976) successive experimental data base query systems, each written entirely in PROLOG.</Paragraph>
<Paragraph position="5"> The first system \[6\] represented the hardware and software catalogues for the Solar 16 series of computers. The user could ask it to build up a computer configuration satisfying his particular needs. We then developed a simpler but more general system which accepts different data bases to be consulted in Spanish or in French \[7\]. This system was later adapted to Portuguese consultation by H. Coelho and L. Pereira (personal communication, 1978), and to English consultation by D. Warren and F. Pereira (personal communication, 1980). In both cases, notably few modifications were needed.</Paragraph>
<Paragraph position="6"> The data base querying features that evolved from the development of these successive systems were coupled with NL representation features into a single logical formalism. Its linguistic motivation and general outline has been described by A. Colmerauer in \[4\], and its motivation from the data base querying view-point has been studied in \[10\]. The formal definition corresponding precisely to our multilingual system can be found in \[11\].</Paragraph>
<Paragraph position="7"> In this paper we present a thorough description of the main principles underlying'these NL processors.</Paragraph>
<Paragraph position="8"> There is some overlap with previous work of the author \[9\], to make this paper self-contained.</Paragraph>
<Paragraph position="9"> Copyright 1981 by the Association for Computational Linguistics. Permission to copy without fee all or part of this material is granted provided that the copies are not made for direct commercial advantage and the Journal reference and this copyright notice are included on the first page. To copy otherwise, or to republish, requires a fee and/or specific permission.  We first discuss what features are convenient in a computationally useful logical representation of NL sentences. Then we present an informal definition of the logical system possessing these features which serves as our internal query language. Finally, we show a step-by-step development of a PROLOG analyser for Spanish, after an informal description of our programming tools.</Paragraph>
<Paragraph position="10"> A complete listing of our PROLOG Spanish grammar is given in the Appendix in the Microfiche Supplement to this issue of the Journal.</Paragraph>
<Paragraph position="11"> The discussion of our analyzer is not intended to be normative: alternative solutions for the problems we encountered are certainly conceivable. Moreover, many of our choices were constrained by the hardware and software tools available to us. We merely show one way of using logic throughout a NL query system, which has proved feasible within modest computational environments. (Our system was first implemented on a 32K, T-1600 minicomputer, using a 1975 version of PROLOG.) The research reported here has motivated further work on logic-programmed NL processors for data bases (e.g. \[2,22,32\], and on the need of extending the original MG formalism \[24\]. On the other hand, the data base component of this system, together with that of the SOLAR 16 system \[6\], has also influenced other researchers (cf. \[2,31\]).</Paragraph>
<Paragraph position="12"> A comprehensive description of the data base component of our system can be found in \[13\]. The SOLAR 16 system has only been reported in \[6\].</Paragraph>
<Paragraph position="13"> 2. Mapping Natural Language into Logic This section discusses several NL processing problems and suggests ways of solving them, through careful choices for the internal language's features. We arrive at a typed, three-valued, set-oriented logical system, which we shall call L3. Its role is a double one. On the one hand, its syntax serves as a more rigorous and informative alternative to NL, making semantic features of NL sentences explicit. On the other hand, its semantics provides a clear definition of the answer-extraction process: the evaluation of an L3 formula yields either a truth value (corresponding to a yes-no question) or the representation of a set (corresponding to a wh-question). Spanish is used as the concrete point of reference. Related work for French is \[4\].</Paragraph>
<Section position="1" start_page="0" end_page="0" type="sub_section">
<SectionTitle>
2.1 Meaningfulness, Ambiguity and Semantic Types
</SectionTitle>
<Paragraph position="0"> A NL processing system must have a means for checking semantic as well as syntactic wellformedness, in order to reject semantically anomalous sentences.</Paragraph>
<Paragraph position="1"> A widespread solution to this problem consists in first generating a &amp;quot;deep structure&amp;quot; of the sentence, taking only syntax into account, and then performing all the necessary semantic operations and checks on it. As has already been observed \[26\], this often implies a tradeoff between syntactic and semantic complexity. But it should be emphasized that it is overall simplicity and efficiency that are important. It seems likely, at least for limited computational resources and a given coverage of NL, that a several-pass analyser will take more space and time than a one-pass analyser. null Mtrreover~ linguists themselves are not unanimous as to whether the semantic component should be separate or intermingled with the syntactic component \[21\].</Paragraph>
<Paragraph position="2"> While taking no sides in this discussion, we shall describe a framework in which syntactic and semantic analysis take place during a one-pass, non-deterministic process, and which, as we have said, has proved sufficient even on small machines.</Paragraph>
<Paragraph position="3"> Where logic is concerned, there is a simple and elegant way of dealing with meaningfulness: by using types. Types, by the way, are also a useful means for associating the universe of predicate calculus to the relations in a particular data base.</Paragraph>
<Paragraph position="4"> They are also useful for improving efficiency: a) by narrowing the search space, as only those values in a variable's associated domain (or type) need be considered, and b) by avoiding futile access to the data base, as absurd queries can be rejected by the analyser on the grounds of domain incompatibility.</Paragraph>
<Paragraph position="5"> Another interest in using types is that they provide an efficient means for discarding readings that are syntactically acceptable but semantically incorrect.</Paragraph>
<Paragraph position="6"> Take for instance the query: Cu~l es el salario del empleado que vive en Lomas? What is the salary of the employee who lives in Lomas? From syntax alone, there is no way to decide whether the antecedent of the relative clause is &amp;quot;the salary of the employee&amp;quot; or &amp;quot;the employee&amp;quot;. But in a type-checking system in which the first argument of the relation &amp;quot;live&amp;quot; is associated with the human domain, and in which employees--and not salaries--are known to belong to this same domain, the first reading is not even possible.</Paragraph>
<Paragraph position="7"> Ambiguities concerning different meanings of a word can often be resolved through domain checking.</Paragraph>
<Paragraph position="8"> Types can also be used to place modifiers other than relative clauses. Our system, however, does not exploit them in this way, although it does check that the modifiers it encounters are of the expected type.</Paragraph>
<Paragraph position="9"> 150 American Journal of Computational Linguistics, Volume 7, Number 3, July-September 1981 Veronica Dahl Translating Spanish into Logic through Logic Finally, let us mention that types in a finite world can contribute to solving an important problem arising in PROLOG programs in which negation is defined by proof failure (i.e., the failure to prove a given fact is taken as proof of its negative counterpart). This is the case for most practical data bases. As a discussion of this problem falls outside the scope of this paper, the interested reader is referred to \[12\].</Paragraph>
<Paragraph position="10">  The use of variable typing to constrain the parse and aid in disambiguation is not new. Many language processors--such as LUNAR \[34\], CO-OP \[17\], LAD-DER \[16\], PHLIQA1 \[1\]--resort to some kind of typing to provide these capabilities.</Paragraph>
<Paragraph position="11"> In our particular approach, the selection of a semantic interpretation is dynamically made on a syntactic basis. This takes place automatically, in the standard PROLOG matching of terms. A simplified explanation follows, and more precise details are given in a later section.</Paragraph>
<Paragraph position="12"> Briefly, referential words (nouns, verbs and adjectives) parse into predicates whose arguments are typed. For instance, the verb &amp;quot;to paint&amp;quot; might induce predicates of the form: paint (person-x,object-y) The expected types of a predicate's arguments are given in lexical entries. Ambiguous referential words have a lexical entry for each possible combination of meaning and syntactic role they can accept. For instance, the word &amp;quot;blue&amp;quot; can designate an object's colour or a person's mood, giving rise to the following entries:</Paragraph>
<Paragraph position="14"> where the function terms act as internal representations of the word. During the parsing process, which is non-deterministic, the correct parse is automatically chosen by matching appropriate terms. For instance, &amp;quot;Which blue door is John painting?&amp;quot; &amp;quot; &amp;quot; would generate a formula containing predicates of the form &amp;quot;door(t-z)&amp;quot;, ,I * paint(person-John,t-z)&amp;quot; and &amp;quot;p(t-z)&amp;quot;, where p is either &amp;quot;sad&amp;quot; or &amp;quot;blue&amp;quot;. Only those lexical rules allowing t to take a value (namely, t=object) that is compatible with its three occurrences will result in a successful parse. Thus, the &amp;quot;sad&amp;quot; interpretation is ruled out by type requirements.</Paragraph>
<Paragraph position="15"> As we shall see later, types are actually represented by expressions that reflect subcategorizations and allow for domain intersections to be found automatically simply by leaving the PROLOG interpreter to match these expressions.</Paragraph>
</Section>
<Section position="2" start_page="0" end_page="0" type="sub_section">
<SectionTitle>
2.2 Presuppositions, Quantifiers and a
Three-Valued Logic
</SectionTitle>
<Paragraph position="0"> Typed calculus in itself is not enough to make all sentences meaningful. A third logical truth value would be useful, because in NL there are two ways in which a statement may fail to be true: either because its negation holds, or because something presupposed by the statement fails to be satisfied. In the latter case, the statement is felt to be pointless rather than false.</Paragraph>
<Paragraph position="1"> There is another reason why it must not be considered false. Take for instance the statement: El sombrerero loco odia a Alicia.</Paragraph>
<Paragraph position="2"> The mad hatter hates Alice.</Paragraph>
<Paragraph position="3"> In a context in which no hatter is mad, it is obviously not true. However, we cannot consider it false either, since then the statement El sombrerero loco no odia a Alicia.</Paragraph>
<Paragraph position="4"> The mad hatter does not hate Alice.</Paragraph>
<Paragraph position="5"> would have to be considered true.</Paragraph>
<Paragraph position="6"> The nonexistence of a referent for the definite noun phrase makes the whole sentence pointless. The existence of more than one referent would also make it pointless. This is because the Spanish singular definite article induces a presupposition of existence and uniqueness on the noun phrase's referent.</Paragraph>
<Paragraph position="7"> Our treatment of quantification has been devised to account for those presuppositions induced by NL quantifiers. We prefer to call them &amp;quot;determiners&amp;quot; &amp;quot;, as they include all articles, cardinal numbers and words l' '1 II '1 such as some , many , etc.</Paragraph>
<Paragraph position="8"> If a sentence contains a determiner, a quantification of the form &amp;quot;those(x,p)&amp;quot; is introduced, where x is a typed variable and p is a logical formula in our system. Its evaluation yields the set of all x's in x's associated domain which satisfy p. According to the determiner's meaning, presuppositions about the cardinality of such a set are represented within the output formula. For instance, &amp;quot;Three blind mice run&amp;quot; is represented as</Paragraph>
<Paragraph position="10"> which says that the cardinality of the set of those blind mice that run is 3.</Paragraph>
<Paragraph position="11"> Definite articles introduce the formula &amp;quot;if(fl,f2)&amp;quot;, the value of which is &amp;quot;pointless&amp;quot; whenever fl fails to be satisfied, and has the same value as f2 if fl is true. Figure 1 shows an example, using the easier-topicture tree representation. The formula represented in Figure 1 will evaluate to &amp;quot;pointless&amp;quot; if the set of mad hatters does not contain exactly one element.</Paragraph>
<Paragraph position="13"> Examples of pragmatically based systems are PHLIQA1 \[1\] and CO-OP \[17\]. The semantic approach is taken for instance in \[23\], where it serves in particular to check presuppositions induced by pronouns. null  We can now examine the general process by which a determiner introduces a &amp;quot;those&amp;quot; formula. Let us consider a sentence consisting of a noun phrase followed by a verb phrase, in which the noun phrase contains a noun introduced by a determiner. We can first represent the sentence through a three-branched quantification of the form: q(x,fl,f2) where q is a quantifier into which the determiner translates, fl is the noun phrase's translation, and f2 is the verb phrase's translation. Intuitively, fl specifies the domain of quantification, and q states what portion of the domain f2 holds for. Our previous example, for instance, can first be represented as in Figure 2.</Paragraph>
<Paragraph position="14"> Notice that the &amp;quot;if&amp;quot; formula could be used for representing other types of presuppositions as well (e.g., those of factive predicates), although our system only uses it for the presuppositions of definite articles. An alternative approach to false presupposition detection is the pragmatic one, in which false presuppositions are caught by noting their empty extensions in the data base, and a two-valued logic is preserved. The question of whether a pragmatic or a semantic analysis of presuppositions is best is far from settled, and we shall not attempt to solve it here. Let us merely note the following: a) The pragmatic and semantic approaches are not incompatible: one can both report pragmatically detected failed assumptions, and assign non-traditional truth values to the sentences containing them.</Paragraph>
<Paragraph position="15"> b) Subtler truth-value assignments facilitate low-cost overall responses of the system.</Paragraph>
<Paragraph position="16"> For instance, a given presupposition's failure can both be pointed out during its local evaluation, and carried on (via truthvalues) to upper levels, for the system itself to see and to possibly take further action of its own (such as trying alternative ways of complying with the request).</Paragraph>
<Paragraph position="17"> Although not exploited in this sense in our system, this feature would allow a more flexible treatment of presuppositions, as it would enable the system to decide, for instance, in which cases they can be safely and usefully ignored.</Paragraph>
<Paragraph position="18"> the</Paragraph>
<Paragraph position="20"> In our implementation, a variable's associated domain depends both on fl and f2 in the following manner: each predicate known to the data base system has a domain associated with each of its arguments.</Paragraph>
<Paragraph position="21"> For instance, &amp;quot;mad&amp;quot; and &amp;quot;hatter&amp;quot; could require their arguments to belong to the human domain, whereas &amp;quot;hate&amp;quot; could require its first argument to belong to the animal domain.</Paragraph>
<Paragraph position="22"> When a three-branched quantification is generated, the variable it creates is typed by the intersection of all those domains it has been associated with by the predicates appearing in either fl or f2. In our example, x's type would be human (the intersection of the human and the animal domains).</Paragraph>
<Paragraph position="23"> Instead of generating a different quantifier for each determiner, it is useful to represent all quantifications through a single one of the form: 152 American Journal of Computational Linguistics, Volume 7, Number 3, July-September 1981 Veronica Dab! Translating Spanish into Logic through Logic for(x,p,c) the intuitive meaning of which is: &amp;quot;c holds for the set E of all x's in x's domain which satisfy p&amp;quot;. In the formula c, the set E will be represented simply by the variable x, so that x plays a double role.</Paragraph>
<Paragraph position="24"> Each quantification is thus assigned an equivalent &amp;quot;for&amp;quot; expression, in which the determiner's meaning is represented. Here are the representations of some of our Spanish quantifiers. The rest are considered in Section 2.2.1.2.</Paragraph>
<Paragraph position="26"> Notice that we have chosen to translate &amp;quot;un&amp;quot; (a) as &amp;quot;at least one&amp;quot; (a frequent sense for &amp;quot;un&amp;quot;). In order to avoid ambiguity, &amp;quot;1&amp;quot; should be used to mean &amp;quot;exactly one&amp;quot;. This convention is particularly useful when negation is involved. For instance, &amp;quot;No tengo un centavo&amp;quot; (I have not a cent) would be wrongly represented in the &amp;quot;exactly one&amp;quot; interpretation: it would state that the number of cents I possess is not one,which means it can either be 0,2,3, etc.</Paragraph>
<Paragraph position="27"> Finally, any formula of the form &amp;quot;for(x,p,c)&amp;quot; can be replaced by just the formula c, in which all occurrences of x have been replaced by the formula: those(x,p) representing the subset of x's domain whose elements satisfy p. This replacement takes place in the data base component of our system.</Paragraph>
<Paragraph position="28"> The reader can now verify that the representations shown in Figures 1 and 2 are equivalent.</Paragraph>
<Paragraph position="29">  In our NL subset, quantifier hierarchy obeys the following three rules, which perhaps are too simplistic, but have proved useful. A more thorough description can be found in \[4\].</Paragraph>
<Paragraph position="30"> Rule 1: A determiner in a verb's subject introduces a quantification which dominates all quantifications introduced by the verb's complement(s). For instance, &amp;quot;Toda rosa tiene (algunas) espinas&amp;quot; (Every rose has (some) thorns) is represented: toda(x,rosa(x),algunas(y,espinas(y),tiene(x,y))) every rose some thorns has Notice that the representation some(y,thorn(y),every(x,rose(x),has(x,y))) would be incorrect, as it means instead: &amp;quot;there exists a particular set of thorns which every rose has&amp;quot;. - Rule 2: Whenever a noun has a complement, the quantification introduced by the complement's determiner dominates the one introduced by the noun's determiner. For instance, &amp;quot;Sfibato autografia el libro de cada visitante&amp;quot; (Sizbato autographs the book of each visitor) is represented: cada(x,visitante(x),el(y,libro-de(x,y), autografia(Sabato,y))) each visitor the book-of autographs - Rule 3: When a referential word (a verb, a noun or an adjective) has more than one complement, quantification takes place from right to left: the rightmost complement generates a quantification which dominates the quantification(s) introduced by the leftmost complement(s). For instance, &amp;quot;Rafil regala un espejo a cada nifio&amp;quot; (Raid gives a mirror to each child) is represented: null cada(x,nino(x),un(y,espejo(y),regala(Raul,y,x))) each child a mirror gives 2.2.1.2 Determiners with a Negative Implication As a general rule, the negation introduced by &amp;quot;no&amp;quot; in a sentence is translated by placing the operator &amp;quot;no&amp;quot; (not) right after the quantification introduced by the subject. For instance, &amp;quot;La indemnizaci6n no compensa el despido de Martin&amp;quot; (The indemnity does not compensate for Martin's dismissal) is represented: la(x,indemnizacion(x),no(el(y,despido-de(Martin,y), compensa(x,y)))) the indemnity not the dismissal-of compensate But negation is not always explicit. The Spanish determiner &amp;quot;ningfin&amp;quot; (no) can be regarded as an implicit negation, since it expresses that no portion of the domain of quantification satisfies the statement involved.</Paragraph>
<Paragraph position="31"> In a non-inverted subject position (e.g., &amp;quot;Ningfin elefante vuela&amp;quot; -No elephant flies), it generates a special quantifier called &amp;quot;ningfin&amp;quot;, the representation of which takes this fact into account, as we have seen.</Paragraph>
<Paragraph position="32"> There are two other cases, however, in which the determiner &amp;quot;ningfin&amp;quot; coexists with an explicit negation. These cases require a different quantifier, as otherwise American Journal of Computational Linguistics, Volume 7, Number 3, July-September 1981 153 Veronica Dahl Translating Spanish into Logic through Logic the negation would be represented twice. These cases are: - In a subject position, with subject-verb inversion: the &amp;quot;ningfln&amp;quot; determiner is assimilated to the &amp;quot;every&amp;quot; quantifier. For instance, &amp;quot;No vino ningfln alumno&amp;quot; (No student came) is represented: todo(x,alumno(x),no(vino(x))) every student not came - In a position other than the subject: the &amp;quot;ningfln&amp;quot; determiner is assimilated to the indefinite article's quantifier. For instance, &amp;quot;Carlos no tiene ningfln hijo&amp;quot; (Carlos has not any chiM) is represented: no(un(x,hijo (x),tiene (Carlos,x))) not a child has Another special case is the negation preceding the &amp;quot;todo&amp;quot; (every) determiner, e.g. &amp;quot;No todo p~jaro canta&amp;quot; (Not every bird sings). The analyser considers &amp;quot;no todo&amp;quot; as a single determiner generating its own associ-</Paragraph>
<Paragraph position="34"></Paragraph>
</Section>
<Section position="3" start_page="0" end_page="0" type="sub_section">
<SectionTitle>
2.3 Distributive, Collective, and Respective Plural
</SectionTitle>
<Paragraph position="0"> Semantically, different kinds of plurals can be distinguished. For instance, the sentence &amp;quot;Ana y Juan hablan espafiol y franc6s&amp;quot; (Ann and John speak Spanish and French), which translates roughly into speak({Ann,John\], {Spanish,French\]), introduces a distributive plural and must therefore evaluate to true (false) if the following formulas are all true (false): speak(Ann,Spanish) speak(John,Spanish) speak(Ann,French) speak(John,French) On the other hand, the sentence &amp;quot;A y B son paralelas&amp;quot; (A and B are parallel), which translates into parallel({A,B\]), introduces a collective plural and must evaluate to either true or false as a result of testing the whole set {A,B} for the property of being parallel.</Paragraph>
<Paragraph position="1"> Finally, the sentence &amp;quot;Ana y Juan ganan respectivamente 1000 y 800 dolares&amp;quot; (Ann and John respectively earn 1000 and 800 dollars), which translates into earn({Ann,John\], {$1000,$800}), introduces a respective plural and must evaluate to true (false) if the following formulas are both true (false):</Paragraph>
<Paragraph position="3"> Notice that both distributive and respective plurals presuppose that the set of formulas to be tested all have the same truth value. Whenever such a presupposition is not satisfied, the plural predication is neither true nor false. In the logic L3, the predication is assigned the &amp;quot;pointless&amp;quot; truth value; but in an improvement of this system, we are proposing the use of a fourth truth value, called &amp;quot;mixed&amp;quot;, for this situation. It seems more appropriate to differentiate &amp;quot;pointless&amp;quot; and &amp;quot;mixed&amp;quot;, so that the system has easy access to locally detected semantic information, in case it needs to take further action.</Paragraph>
<Paragraph position="4"> Distributive and collective plurals are distinguished in the lexicon by syntactically marking the relation they translate into.</Paragraph>
<Paragraph position="5"> Respective plurals are not handled in our implementation: they were introduced (although with only two logical values) in the Portuguese version of our system, where the analyser recognizes them through the words &amp;quot;respective&amp;quot; and &amp;quot;respectively&amp;quot;.</Paragraph>
</Section>
<Section position="4" start_page="0" end_page="0" type="sub_section">
<SectionTitle>
2.4 Sets
</SectionTitle>
<Paragraph position="0"> Relations must be allowed to apply on sets if we are to deal with collective relations. Sets are moreover natural enough in data base applications, as retrieval often concerns sets of objects satisfying certain properties. They can also be useful for defining types. We represent them either extensionally (through lists) or intensionally (through &amp;quot;those&amp;quot; formulas).</Paragraph>
<Paragraph position="1"> Set operations are implicit while parsing--as dynamic type checking involves intersecting various domains--and also during formula evaluation (i.e., in the data base component of our system). In both cases they are kept invisible to the user.</Paragraph>
<Paragraph position="2"> In particular, the user can refer to either sets or individuals when defining a new relation, and rely on the system to make appropriate inferences from his definitions.</Paragraph>
</Section>
<Section position="5" start_page="0" end_page="0" type="sub_section">
<SectionTitle>
2.5 Linguistic Coverage
</SectionTitle>
<Paragraph position="0"> Our NL subset is extendible in the sense that the user can define those referential words (nouns, verbs and adjectives) associated with his particular data base. This includes the definition of synonyms, always useful regarding different users' views of a data base.</Paragraph>
<Paragraph position="1"> The analyser uses a syntactic variant of PROLOG, called (normalized) metamorphosis grammars (MGs) \[5\]. As such, MGs share a most useful feature of logic programs: a problem's description and the program which solves it are one and the same. This is due to the existence of an operational as well as a declarative interpretation for logic programs \[19\].</Paragraph>
<Paragraph position="2"> 154 American Journal of Computational Linguistics, Volume 7, Number 3, July-September 1981 Veronica Dahl Translating Spanish into Logic through Logic Thus, the grammar shown in the Appendix (in the Microfiche Supplement) both provides a formal definition of our linguistic coverage (in its declarative reading) and is the analyser itself (in its procedural reading, which the PROLOG interpreter gives it).</Paragraph>
<Paragraph position="3"> An informal description of its coverage follows.</Paragraph>
<Paragraph position="4"> - Fixed vocabulary Determiners: el la los las un una unos unas the a some ningfm todo i no every any cardinal number Prepositions: all Spanish prepositions Conjunction: y and Relative pronouns: que quien donde cuyo cual(es) ~: which who where whose Interrogative pronouns: qu6 cu~nto(s) d6nde qui6n cu~l which how much/many where who which Negative particle: no Variable vocabulary. Each particular data base includes a definition of its associated proper names, nouns, adjectives and verbs. Only simple verbal forms in the third person are allowed.</Paragraph>
<Paragraph position="5"> - Structure. Sentences are either declarative or interrogative, in the active voice. A declarative sentence consists of a subject, an optional negation particle, a verb and its modifiers (in the restricted sense described below).</Paragraph>
<Paragraph position="6"> A subject consists of a noun phrase. A noun phrase is either a series of proper names or a kernel followed by noun modifiers and relative clauses (both optional).</Paragraph>
<Paragraph position="7"> A noun phrase's kernel consists of an optional determiner, an optional series of adjectives, a noun, and possibly a series of adjectival groups. Mass nouns are not dealt with. An adjectival group is an adjective with modifiers.</Paragraph>
<Paragraph position="8"> A modifier (of a noun, an adjective or a verb) is just a noun phrase as described above, possibly introduced by a preposition.</Paragraph>
<Paragraph position="9"> Both relative and interrogative clauses are modified versions of a declarative sentence, where some elements have changed places and some have been replaced by a relative or an interrogative pronoun. Figure 3 gives a sample consultation session with the system. The data base being consulted concerns individuals grouped as either salesmen, administrative employees, managers, sites, departments or salaries. The first two sets are grouped to form the employee domain, which together with the manager domain forms the human domain. The data base contains the  1. Hola. (Hello.) Diga. (I am listening.) 2. Con qui6n est~ casada Eva? (Who is Eva married to?) Con Adhn. (To Adhn.) 3. Aden y Eva viven en Lanfis?  work-with and manager-of. Unary relations named after each domain are implicit in any data base.</Paragraph>
</Section>
</Section>
</Paper>

