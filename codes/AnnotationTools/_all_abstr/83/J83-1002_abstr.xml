<?xml version="1.0" standalone="yes"?>

<Paper uid="J83-1002">
<Title>Denotational Semantics for &amp;quot;'Natural'&amp;quot; Language Question-Answering Programs 1</Title>
<Section position="2" start_page="0" end_page="0" type="abstr">
<SectionTitle>
1. Introduction
</SectionTitle>
<Paragraph position="0"> We advocate the use of Scott-Strachey denotational semantics for &amp;quot;natural&amp;quot; language question-answering programs. The majority of this paper demonstrates the use of denotational semantics for a small question answerer. The types of questions possible are similar to those in Harris (1979), Winograd (1972), and Woods (1972). The analysis is not as deep as in Karttunen (1977) or similar studies, as it is oriented to the specification of useful, but linguistically modest, capabilities. null Before the demonstration, we discuss the benefits of formal semantics and why denotational semantics is an appropriate formalization. The semantics of a question answerer is given by defining the action of the program for each possible input. An informal semantic description, perhaps in narrative form, is necessary for a potential user who wants to know what questions he may ask and what sort of answers the program will provide. Informal meanings are also valuable to the designer and implementer of a question answerer. However, the designer and implementer must understand all aspects of a proposed question answerer in a precise unambiguous way that informal  1 This research was supported in part by NSF grants MCS7708486 and MCS8003433.</Paragraph>
<Paragraph position="1"> 2 Current Address: Department of Computer Science, University of Colorado, Boulder, CO 80309.</Paragraph>
<Paragraph position="2">  methods do not provide. In short, a formal method of specifying the semantics is needed at the design and implementation stage (see Ashcroft and Wadge 1982).</Paragraph>
<Paragraph position="3"> Once a formal semantics has been given, it can be put to other uses as well. It can provide the basis for a rigorous proof of correctness of an implementation. Furthermore, formal specifications might allow partial automation of the implementation process in the same way that automatic compiler-writers produce parts of a compiler from a formal specification of a programming language (see Johnson 1975). With the advent of at least one commercially available &amp;quot;natural&amp;quot; language question-answering program (Harris 1979), these advantages become even more concrete.</Paragraph>
<Paragraph position="4"> If there is a familiarity to these arguments, it is because the same reasoning is used to justify formal semantics for programming languages. The problems of design and analysis of question answerers are much the same for programming languages - Benson (1975) argues this point at length. An obvious approach is to apply a programming language technique - denotational semantics - to the problem of formally specifying a question answerer. As a bonus, the method is understood by many programmers and software engineers through introductory textbooks such as Stoy (1977), Gordon (1979), McGettrick (1980), Pagan (1981), and Tennent (1981). Additionally, linguistic treatments of natural language, such as Montague (1973), are basically denotational and we can modify such Copyright 1983 by the Association for Computational Linguistics. Permission to copy without fee all or part of this material is granted provided that the copies are not made for direct commercial advantage and the Journal reference and this copyright notice are included on the first page. To copy otherwise, or to republish, requires a fee and/or specific permission. 03 62-613X/83/010011-11 $03.00 American Journal of Computational Linguistics, Volume 9, Number 1, January-March 1983 11 Michael G. Main and David B. Benson Denotational Semantics for 'Natural' Language Q-A Programs treatments to meet our needs.</Paragraph>
<Paragraph position="5"> In denotational semantics for programming languages, evaluation functions map program segments into objects in various semantic domains. These objects are taken as the meanings of the program segments, and determine the output of a program. Similarly, in the semantics of a question answerer, evaluation functions map input (questions) into objects that determine the output (answers).</Paragraph>
<Paragraph position="6"> Deciding what objects are in the semantic domains has a fundamental effect on the capabilities of the overlying question answerer, as well as an effect on the usefulness and clarity of the semantic descriptions.</Paragraph>
<Paragraph position="7"> Lewis (1972) discusses these considerations for natural language sentences and the domains described in section 2 are based on his, although the treatment of questions is closer to Ajdukiewicz (1926). Also introduced in section 2 are the lambda expressions that denote individual semantic objects. Such expressions have been used in denotational semantics of programming languages (see Scott 1970, Milne and Strachey 1976, Stoy 1977) and in treatments of fragments of English by Montague (1973).</Paragraph>
<Paragraph position="8"> In section 3, evaluation functions mapping inputs for a small question answerer to objects in the semantic domain are given. The allowable questions are defined by a category grammar as has been done by Ajdukiewicz (1935), Carnap (1937), Lewis (1972), Montague (1973), and others. An account of the answer relationship is given in section 4.</Paragraph>
<Paragraph position="9"> In the final section, we briefly describe an implementation of the question answerer and suggest some broad principles for designing question answerers.</Paragraph>
</Section>
</Paper>

