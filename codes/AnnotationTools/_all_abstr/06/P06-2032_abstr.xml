<?xml version="1.0" standalone="yes"?>

<Paper uid="P06-2032">
<Title>Pros Cons Practice Export Economy Name management Use in linguistically motivated Not with multiple inheritance sub-hierarchy Not with conjunction Not with disjunction Not with multiple reuse Colours Economy ++ Non deterministic Multiple reuse OK Not with inheritance Use when a given class and identically named identifiers combines with many classes Interface Global Name management Use for Syntax/Semantic interface Explicit identification Usable in all cases Uneconomical Last Resort solution</Title>
<Section position="2" start_page="0" end_page="247" type="abstr">
<SectionTitle>
Abstract
</SectionTitle>
<Paragraph position="0"> We claim that existing specification languages for tree based grammars fail to adequately support identifier managment.</Paragraph>
<Paragraph position="1"> We then show that XMG (eXtensible Meta-Grammar) provides a sophisticated treatment of identifiers which is effective in supporting a linguist-friendly grammar design. null 1 Specifying tree-based grammars Whilst the development of standard unification-based grammars is well supported by the design of formalisms such as PATR-II, Ale or TDL (Krieger and Schafer, 1994), the situation is less well established for Tree-Based Grammars such as Tree Adjoining Grammars (Joshi and Schabes, 1997), Tree Description Grammars (Kallmeyer, 1996) or Interaction Grammars (Perrier, 2003).</Paragraph>
<Paragraph position="2"> Roughly, two main types of specification formalism for Tree-Based Grammars can be distinguished: formalisms based on tree fragments and non monotonic inheritance and formalisms based on tree descriptions and monotonic inheritance.</Paragraph>
<Paragraph position="3"> The tree fragment approach is advocated in (Evans et al., 1995) which proposes to encode lexicalised TAGs using the DATR representation language1. In this approach, tree fragments are combined within a non monotonic inheritance hierarchy. Furthermore, new fragments can be derived from existing ones by means of lexical rules. This first approach suffers from the procedural character of non-monotonic inheritance. In specifying the grammar, the grammar writer must keep 1A tree based approach is also used in(Becker, 2000) but this time in combination with metarules. In that particular approach, procedural aspects also come into play as the order in which metarules apply affect the results.</Paragraph>
<Paragraph position="4"> in mind the order in which non-monotonic statements have been made so as to be able to predict how explicit statements interact with defaults and non-monotonic inheritance in determining the final output. When developing a large coverage grammar, this rapidly become extremely cumbersome. Moreover, as (Candito, 1996) remarks, non-monotonicity may result in an information loss which makes it impossible to express the relation existing for instance between an active object and the corresponding passive subject.</Paragraph>
<Paragraph position="5"> The approach based on tree descriptions (often called, the metagrammar approach) obviates the procedural character of the non-monotonic approach by taking tree descriptions rather than trees to be the basic units (Candito, 1996; Xia et al., 1999; Vijay-Shanker and Schabes, 1992). In essence, tree fragments are described using tree descriptions and tree descriptions are combined through conjunction or inheritance. The idea is that the minimal models satisfying the resulting descriptions are TAG elementary trees. In some cases, lexical rules are also used to derive new trees from existing ones.</Paragraph>
<Paragraph position="6"> One main drawback with this second type of approach concerns the management of node identifiers. Either nodes are represented by nameless variables and node identification is forced by well-formedness constraints e.g., wff-constraints on trees and wff-constraints given by the input tree description (cf. e.g., (Duchier and Gardent, 1999)) or nodes are named and nodes with identical names are forced to denote the same entity. The first option is unrealistic when developing a large core grammar as it is easy to omit a necessary constraint and thereby permit overgeneration (the description will be satisfied by more trees than intended). The second option greatly degrades  modularity as the grammar writer must remember which names were used where and with which interpretation. As we shall see below, it also has the undesirable effect that the same tree fragment cannot be used twice in a given tree description.</Paragraph>
<Paragraph position="7"> Nevertheless, this is the option that is adopted in most grammar formalisms and grammar compilers (Candito, 1996; Xia et al., 1999; Gaiffe et al., 2002).</Paragraph>
<Paragraph position="8"> In this paper, we present an approach which remedies these shortcomings by combining monotonic inheritance of tree descriptions with an explicit management of identifier scope and identifiers equality2. The proposed approach thus eschews both the inconvenients induced by a non monotonic framework (by using tree descriptions rather than trees) and those resulting from a global treatment of identifiers (by providing greater expressivity wrt identifiers).</Paragraph>
<Paragraph position="9"> Specifically, we show that the proposed approach supports several ways of identifying (node or feature) values, we motivate this multiplicity and we identify the linguistic and/or technical criteria for choosing among the various possibilities. The paper starts in section 2 by introducing the syntax of the XMG formalism. In section 3, we show that XMG provides four different ways of identifying two (node or variable) identifiers. In section 4, we motivate each of these four different ways and indicate when each of them can and should be used.</Paragraph>
</Section>
</Paper>

