<?xml version="1.0" standalone="yes"?>

<Paper uid="P94-1041">
<Title>Detecting and Correcting Speech Repairs</Title>
<Section position="1" start_page="0" end_page="299" type="abstr">
<SectionTitle>
Abstract
</SectionTitle>
<Paragraph position="0"> Interactive spoken dialog provides many new challenges for spoken language systems. One of the most critical is the prevalence of speech repairs. This paper presents an algorithm that detects and corrects speech repairs based on finding the repair pattern. The repair pattern is built by finding word matches and word replacements, and identifying fragments and editing terms. Rather than using a set of pre-built templates, we build the pattern on the fly. In a fair test, our method, when combined with a statistical model to filter possible repairs, was successful at detecting and correcting 80% of the repairs, without using prosodic information or a parser.</Paragraph>
<Paragraph position="1"> Introduction Interactive spoken dialog provides many new challenges for spoken language systems. One of the most critical is the prevalence of speech repairs. Speech repairs are dysfluencies where some of the words that the speaker utters need to be removed in order to correctly understand the speaker's meaning. These repairs can be divided into three types: fresh starts, modifications, and abridged. A fresh start is where the speaker abandons what she was saying and starts again.</Paragraph>
<Paragraph position="2"> the current plan is we take - okay let's say we start with the bananas (d91-2.2 uttl05) A modification repair is where the speech-repair modifies what was said before.</Paragraph>
<Paragraph position="3"> after the orange juice is at - the oranges are at the OJ factory (d93-19.3 utt59) An abridged repair is where the repair consists solely of a fragment and/or editing terms.</Paragraph>
<Paragraph position="4"> we need to -um manage to get the bananas to Dansville more quickly (d93-14.3 utt50) These examples also illustrate how speech repairs can be divided into three intervals: the removed text, the editing terms, and the resumed text (cf. Levelt, (1983), Nakatani and Hirschberg, (1993)). The removed text, which might end in a word fragment, is the text that the speaker intends to replace. The end of the removed text is called the interruption point, which is marked in the above examples as &amp;quot;-&amp;quot;. This is then followed by editing terms, which can either be filled pauses, such as &amp;quot;urn&amp;quot;, &amp;quot;uh&amp;quot;, and &amp;quot;er&amp;quot;, or cue phrases, such as &amp;quot;I mean&amp;quot;, &amp;quot;I guess&amp;quot;, and &amp;quot;well&amp;quot;. The last interval is the resumed text, the text that is intended to replace the removed text. (All three intervals need notbe present in a given speech repair.) In order to correct a speech repair, the removed text and the editing terms need to be deleted in order to determine what the speaker intends to say. 1 In our corpus of problem solving dialogs, 25% of turns contain at least one repair, 67% of repairs occur with at least one other repair in the turn, and repairs in the same turn occur on average within 6 words of each other. As a result, no spoken language system will perform well without an effective way to detect and correct speech repairs.</Paragraph>
<Paragraph position="5"> We propose that most speech repairs can be detected and corrected using only local clues--it should not be necessary to test the syntactic or semantic well-formedness of the entire utterance. People do not seem to have problems comprehending speech repairs as they occur, and seem to have no problem even when multiple repairs occur in the same utterance. So, it should be possible to construct an algorithm that runs on-line, processing the input a word at a time, and committing to whether a string of words is a repair by the end of the string. Such an algorithm could precede a parser, or even operate in lockstep with it.</Paragraph>
<Paragraph position="6"> An ulterior motive for not using higher level syntactic or semantic knowledge is that the coverage of parsers and semantic interpreters is not sufficient for unrestricted dialogs. Recently, Dowding et al. (1993) reported syntactic and semantic coverage of 86% for the DARPA Airline reservation corpus (Dowding et al., 1993). Unrestricted dialogs will present even more difficulties; not only will the speech be less grammatical, but there is also the problem of segmenting the dialog into utterance units (cf. Wang and Hirschberg, 1992)* If speech repairs can be detected and corrected before parsing and semantic interpretation, this should simplify those modules as well as make them more robust.</Paragraph>
<Paragraph position="7"> In this paper, we present an algorithm that detects and corrects modification and abridged speech repairs without doing syntactic and semantic processing. The algorithm determines the text that needs to be removed by building a repair pattern, based on identification of word fragments, editing ~The removed text and editing terms might still contain pragmatic information, as the following example displays, &amp;quot;Peter was *.. well.., he was fired.</Paragraph>
<Paragraph position="8">  terms, and word correspondences between the removed and the resumed text (cf. Bear, Dowding and Shriberg, 1992).</Paragraph>
<Paragraph position="9"> The resulting potential repairs are then passed to a statistical model that judges the proposal as either fluent speech or an actual repair.</Paragraph>
<Section position="1" start_page="295" end_page="295" type="sub_section">
<SectionTitle>
Previous Work
</SectionTitle>
<Paragraph position="0"> Several different strategies have been discussed in the literature for detecting and correcting speech repairs. A way to compare the effectiveness of these approaches is to look at their recall and precision rates. For detecting repairs, the recall rate is the number of correctly detected repairs compared to the number of repairs, and the precision rate is the number of detected repairs compared to the number of detections (including false positives). But the true measures of success are the correction rates. Correction recall is the number of repairs that were properly corrected compared to the number of repairs. Correction precision is the number of repairs that were properly corrected compared to the total number of corrections.</Paragraph>
<Paragraph position="1"> Levelt (1983) hypothesized that listeners can use the following rules for determining the extent of the removed text (he did not address how a repair could be detected). If the last word before the interruption is of the same category as the word before, then delete the last word before the interruption.</Paragraph>
<Paragraph position="2"> Otherwise, find the closest word prior to the interruption that is the same as the first word after the interruption. That word is the start of the removed text. Levelt found that this strategy would work for 50% of all repairs (including fresh starts), get 2% wrong, and have no comment for the remaining 48%. 2 In addition, Levelt showed that different editing terms make different predictions about whether a repair is a fresh start or not. For instance, &amp;quot;uh&amp;quot; strongly signals an abridged or modification repair, whereas a word like &amp;quot;sorry&amp;quot; signals a fresh start.</Paragraph>
<Paragraph position="3"> Hindle (1983) addressed the problem of correcting self-repairs by adding rules to a deterministic parser that would remove the necessary text. Hindle assumed the presence of an edit signal that would mark the interruption point, and was able to achieve a recall rate of 97% in finding the correct repair. For modification repairs, Hindle used three rules for &amp;quot;expuncting&amp;quot; text. The first rule &amp;quot;is essentially a non-syntactic rule&amp;quot; that matches repetitions (of any length); the second matches repeated constituents, both complete; and the third, matches repeated constituents, in which the first is not complete, but the second is.</Paragraph>
<Paragraph position="4"> However, Hindle's results are difficult to translate into actual performance. First, his parsing strategy depends upon the &amp;quot;successful disambiguation of the syntactic categories.&amp;quot; Although syntactic categories can be determined quite well by their local context (as is needed by a deterministic parser), Hindle admits that &amp;quot;\[self-repair\], by its nature, disrupts the local context.&amp;quot; Second, Hindle's algorithm depends on the presence of an edit signal; so far, however, the abrupt cut-off 2Levelt claims (pg. 92) that the hearer can apply his strategy safely for 52% of all repairs, but this figure includes the 2% that the hearer would get wrong.</Paragraph>
<Paragraph position="5"> that some have suggested signals the repair (cf. Labov, 1966) has been difficult to find, and it is unlikely to be represented as a binary feature (cf. Nakatani and Hirschberg, 1993).</Paragraph>
<Paragraph position="6"> The SRI group (Bear et al., 1992) employed simple pattern matching techniques for detecting and correcting modification repairs. 3 For detection, they were able to achieve a recall rate of 76%, and a precision of 62%, and they were able to find the correct repair 57% of the time, leading to an over-all correction recall of 43% and correction precision of 50%. They also tried combining syntactic and semantic knowledge in a &amp;quot;parser-first&amp;quot; approach--first try to parse the input and if that fails, invoke repair strategies based on word patterns in the input. In a test set containing 26 repairs (Dowding et al., 1993), they obtained a detection recall rate of 42% and a precision of 84.6%; for correction, they obtained a recall rate of 30% and a recall rate of 62%.</Paragraph>
<Paragraph position="7"> Nakatani and Hirschberg (1993) investigated using acoustic information to detect the interruption point of speech repairs. In their corpus, 74% of all repairs are marked by a word fragment. Using hand-transcribed prosodic annotations, they trained a classifier on a 172 utterance training set to identify the interruption point (each utterance contained at least one repair). On a test set of 186 utterances each containing at least one repair, they obtained a recall rate of 83.4% and a precision of 93.9% in detecting speech repairs. The clues that they found relevant were duration of pause between words, presence of fragments, and lexical matching within a window of three words. However, they do not address the problem of determining the correction or distinguishing modification repairs from abridged repairs.</Paragraph>
<Paragraph position="8"> Young and Matessa (Young and Matessa, 1991) have also done work in this area. In their approach, speech repairs are corrected after a opportunistic case-frame parser analyzes the utterance. Their system looks for parts of the input utterance that were not used by the parser, and then uses semantic and pragmatic knowledge (of the limited domain) to correct the interpretation.</Paragraph>
</Section>
<Section position="2" start_page="295" end_page="296" type="sub_section">
<SectionTitle>
The Corpus
</SectionTitle>
<Paragraph position="0"> As part of the TRAINS project (Allen and Schubert, 199 I), which is a long term research project to build a conversationally proficient planning assistant, we are collecting a corpus of problem solving dialogs. The dialogs involve two participants, one who is playing the role of a user and has a certain task to accomplish, and another, who is playing the role of the system by acting as a planning assistant. 4 The entire corpus consists of 112 dialogs totaling almost eight hours in length and containing about 62,000 words, 6300 speaker turns, and 40 different speakers. These dialogs have been segmented into utterance files (cf. Heeman and Allen, 1994b); words 3They referred to modification repairs as nontrivial repairs, and to abridged repairs as trivial repairs; however, these terms are misleading. Consider the utterance &amp;quot;send it back to Elmira uh to make OJ&amp;quot;. Determining that the corrected text should be &amp;quot;send it back to Elmira to make OJ&amp;quot; rather than &amp;quot;send it back to make OJ&amp;quot; is non trivial.</Paragraph>
<Paragraph position="1"> 4Gross, Allen and Traum (1992) discuss the manner in which the first set of dialogues were collected, and provide transcriptions.  have been transcribed and the speech repairs have been annotated. For a training set, we use 40 of the dialogs, consisting of 24,000 words, 725 modification and abridged repairs, and 13 speakers; and for testing, 7 of the dialogs, consisting of 5800 words, 142 modification and abridged repairs, and seven speakers, none of which were included in the training set.</Paragraph>
<Paragraph position="2"> The speech repairs in the dialog corpus have been handannotated. There is typically a correspondence between the removed text and the resumed text, and following Bear, Dowding and Shriberg (1992), we annotate this using the labels m for word matching and r for word replacements (words of the same syntactic category). Each pair is given a unique index. Other words in the removed text and resumed text are annotated with an x. Also, editing terms (filled pauses and clue words) are labeled with et, and the moment of interruption with int, which will occur before any editing terms associated with the repair, and after the fragment, if present. (Further details of this scheme can be found in (Heeman and Allen, 1994a).) Below is a sample annotation, with removed text &amp;quot;go to oran-&amp;quot;, editing term &amp;quot;um&amp;quot;, and resumed text &amp;quot;go to&amp;quot; (d93-14.2 utt60). gol tol oran-I uml gol tol Corning ml I m2 I x Iint\[ et I ml I m2 I A speech repair can also be characterized by its repair pattern, which is a string that consists of the repair labels (word fragments are labeled as -, the interruption point by a period, and editing terms by e). The repair pattern for the example is mm-.emm.</Paragraph>
</Section>
<Section position="3" start_page="296" end_page="296" type="sub_section">
<SectionTitle>
Repair Indicators
</SectionTitle>
<Paragraph position="0"> In order to correct speech repairs, we first need to detect them. If we were using prosodic information, we could focus on the actual interruption point (cf. Nakatani and Hirschberg, 1993); however, we are restricting ourselves to lexical clues, and so need to be more lenient.</Paragraph>
<Paragraph position="1"> Table 1 gives a breakdown of the modification speech repairs and the abridged repairs, based on the handannotations} Modification repairs are broken down into four groups, single word repetitions, multiple word repetitions, one word replacing another, and others. Also, the percentage of each type of repair that include fragments and editing terms is given.</Paragraph>
<Paragraph position="2"> This table shows that strictly looking for the presence of fragments and editing terms will miss at least 41% of speech repairs. So, we need to look at word correspondences in order to get better coverage of our repairs. In order to keep the false positive rate down, we restrict ourselves to the following types of word correspondences: (1) word matching with at most three intervening words, denoted by m-m; (2) two adjacent words matching two others with at most 6 words intervening, denoted by mm-mm; and (3) adjacent replacement, denoted by rr. Table 2 the number of repairs in the 5Eight repairs were excluded from this analysis. These repairs could not be automatically separated from other repairs that overlapped with them.</Paragraph>
<Paragraph position="3">  training corpus that can be deleted by each clue, based on the hand-annotations. For each clue, we give the number of repairs that it will detect in the first column. In the next three columns, we give a breakdown of these numbers in terms of how many clues apply. As the table shows, most repairs are signal by only one of the 3 clues.</Paragraph>
<Paragraph position="4"> Total I 1 clue I 2 clues I 3 clues I  164 63 5 296 111 5 n.a. n.a. n.a.</Paragraph>
<Paragraph position="5"> 587 I 116 I 5  Although the m-m clue and mm-mm clue do not precisely locate the interruption point, we can, by using simple lexical clues, detect 97.7% (708/725) of all the repairs. But, we still will have a problem with false positives, and detecting the extent of the repair.</Paragraph>
</Section>
<Section position="4" start_page="296" end_page="298" type="sub_section">
<SectionTitle>
Determining the Correction
</SectionTitle>
<Paragraph position="0"> Based on the work done at SRI (Bear, Dowding and Shriberg, 1992), we next looked at the speech repair patterns in our annotated training corpus. If we can automatically determine the pattern, then the deletion of the removed text along with the editing terms gives the correction. Since the size of the pattern can be quite large, especially when editing terms and word fragments are added in, the number of possible templates becomes very large. In our training corpus of 450 modification repairs, we found 72 different patterns (not including variations due to editing terms and fragments). All patterns with at least 2 occurrences are listed in table 3.</Paragraph>
<Paragraph position="1"> Adding to the Pattern Rather than doing template matching, we build the repair pattern on the fly. When a possible repair is detected, the detection itself puts constraints on the repair pattern. For instance, if we detect a word fragment, the location of the fragment limits the extent of the editing terms. It also limits</Paragraph>
<Paragraph position="3"> the extent of the resumed text and removed text, and so on restricts word correspondences that can be part of the repair.</Paragraph>
<Paragraph position="4"> In this section, we present the rules we use for building repair patterns. These rules not only limit the search space, but more importantly, are intended to keep the number of false positives as low as possible, by capturing a notion of 'well-formness' for speech repairs.</Paragraph>
<Paragraph position="5"> The four rules listed below follow from the model of repairs that we presented in the introduction. They capture how a repair is made up of three intervals--the removed text, which can end in a word fragment, possible editing terms, and the resumed text--and how the interruption point is follows the removed text and precedes the editing terms.</Paragraph>
<Paragraph position="6">  1. Editing terms must be adjacent.</Paragraph>
<Paragraph position="7"> 2. Editing terms must immediately follow the interruption point.</Paragraph>
<Paragraph position="8"> 3. A fragment, if present, must immediately precede the interruption point.</Paragraph>
<Paragraph position="9"> 4. Word correspondences must straddle the interruption point and can not be marked on a word labeled as an  editing term or fragment.</Paragraph>
<Paragraph position="10"> The above rules alone do not restrict the possible word correspondences enough. Based on an analysis of the hand-coded repairs in the training corpus, we propose the following additional rules.</Paragraph>
<Paragraph position="11"> Rule (5) captures the regularity that word correspondences of a modification repair are rarely, if ever, embedded in each other. Consider the following exception.</Paragraph>
<Paragraph position="12"> how would that - how long that would take In this example, the word correspondence involving &amp;quot;that&amp;quot; is embedded inside of the correspondence on &amp;quot;would&amp;quot;. The speaker actually made a uncorrected speech error (and so not a speech repair) in the resumed text, for he should have said &amp;quot;how long would that take.&amp;quot; Without this ungrammaticality, the two correspondences would not have been embedded, and so would not be in conflict with the following rule. 5. Word correspondences must be cross-serial; a word correspondence cannot be embedded inside of another correspondence.</Paragraph>
<Paragraph position="13"> The next rule is used to limit the application of word correspondences when no correspondences are yet in the repair pattern. In this case, the repair would have been detected by the presence of a fragment or editing terms. This rule is intended to prevent spurious word correspondences from being added to the repair. For instance in the following example, the correspondence between the two instances of 'T' is spurious, since the second 'T' in fact replaces &amp;quot;we&amp;quot;. I think we need to uh I need So, when no correspondences are yet included in the repair, the number of intervening words needs to be limited. From our test corpus, we have found that 3 intervening words, excluding fragments and editing terms is sufficient.</Paragraph>
<Paragraph position="14"> 6. If there are no other word correspondences, there can only be 3 intervening words, excluding fragments and editing terms, between the first part and the second part of the correspondence.</Paragraph>
<Paragraph position="15"> The next two rules restrict the distance between two word correspondences. Figure 1 shows the distance between two word correspondences, indexed by i and j. The intervals x and y are sequences of the words that occur between the marked words in the removed text and in the resumed text, respectively. The word correspondences of interest are those that are adjacent, in order words, the ones that have no labeled words in the x and y intervals.</Paragraph>
<Paragraph position="17"> For two adjacent word correspondences, Rule (7) ensures that there is at most 4 intervening words in the removed text, and Rule (8) ensures that there are at most 4 intervening words in the resumed text.</Paragraph>
<Paragraph position="18"> 7. In the removed text, two adjacent matches can have at most 4 intervening words (Izl &lt; 4).</Paragraph>
<Paragraph position="19"> 8. In the resumed text, two adjacent matches can have at most 4 intervening words (lyl -&lt; 4).</Paragraph>
<Paragraph position="20"> The next rule, Rule (9), is used to capture the regularity that words are rarely dropped from the removed text, instead they tend to be replaced.</Paragraph>
<Paragraph position="21"> 9. For two adjacent matches, the number of intervening words in the removed text can be at most one more than the number of intervening words in the resumed text (Izl ___ lyl + 1).</Paragraph>
<Paragraph position="22"> The last rule, Rule (10), is used to restrict word replacements. From an analysis of our corpus, we found that word replacement correspondences are rarely isolated from other word correspondences.</Paragraph>
<Paragraph position="23"> 10. A word replacement (except those added by the detection clues) must either only have fragments and editing terms between the two words that it marks, or there must be a word correspondence in which there are no intervening words in either the removed text or the resumed text (x = y = 0).</Paragraph>
</Section>
<Section position="5" start_page="298" end_page="298" type="sub_section">
<SectionTitle>
An Example
</SectionTitle>
<Paragraph position="0"> To illustrate the above set of well-formedness constraints on repair patterns, consider the example given above &amp;quot;I think we need to - uh I need.&amp;quot; The detection clues will mark the word &amp;quot;uh&amp;quot; as being a possible editing term, giving the partial pattern given below.</Paragraph>
<Paragraph position="1"> I think we need to uh\[ I need et I Now let's consider the two instances of &amp;quot;I&amp;quot;. Adding this correspondence to the repair pattern will violate Rule (6), since there are four intervening words, excluding the editing terms. The correspondence between the two instances of 'need' is acceptable though, since it straddles the editing term, and there are only two intervening words between the corresponding words, excluding editing terms.</Paragraph>
<Paragraph position="2"> Even with the correspondence between the two instances of'need', the matching between the 'I's still cannot be added. There are 2 intervening words between 'T' and &amp;quot;need&amp;quot; in the removed text, but none in the resumed side, so this correspondence violates Rule (9). The word replacement of &amp;quot;we&amp;quot; by the second instance of 'T', does not violate any of the rules, including Rule (10), so it is added, resulting in the following labeling.</Paragraph>
<Paragraph position="4"> Our algorithm for labeling potential repair patterns encodes the assumption that speech repairs can be processed one at a time. The algorithm runs in lockstep with a part-of-speech tagger (Church, 1988), which is used for deciding possible word replacements. Words are fed in one at a time. The detection clues are checked first. If one of them succeeds, and there is not a repair being processed, then a new repair pattern is started. Otherwise, if the clue is consistent with the current repair pattern, then the pattern is updated; otherwise, the current one is sent off to be judged, and a new repair pattern is started.</Paragraph>
<Paragraph position="5"> When a new repair is started, a search is made to see if any of the text can contribute word correspondences to the repair.</Paragraph>
<Paragraph position="6"> Likewise, if there is currently a repair being built, a search is made to see if there is a suitable word correspondence for the current word. Anytime a correspondence is found, a search is made for any additional correspondences that it might sanction.</Paragraph>
<Paragraph position="7"> Since there might be a conflict between two possible correspondences that can be added to a labeling, the one that involves the most recent pair of words is preferred. For instance, in the example above, the correspondence between the second instance of 'T' and &amp;quot;we&amp;quot; is prefered over the correspondence between the second instance of 'T' and the first.</Paragraph>
<Paragraph position="8"> The last issue to account for is the judging of a potential repair. If the labeling consists of just cue phrases, then it is judged as not being a repair. 6 Otherwise, if the point of 6This prevents phrases such as &amp;quot;I guess&amp;quot; from being marked as interruption of the potential repair is uniquely determined, then it is taken as a repair. This will be the case if there is at least one editing term, a word fragment, or there are no unaccounted for words between the last removed text part of the last correspondence and the resumed text part of the first correspondence.</Paragraph>
</Section>
<Section position="6" start_page="298" end_page="298" type="sub_section">
<SectionTitle>
Results of Pattern Building
</SectionTitle>
<Paragraph position="0"> The input to the algorithm is the word transcriptions, augmented with turn-taking markers. Since we are not trying to account for fresh starts, break points are put in to denote the cancel, and its editing terms are deleted (this is done to prevent the algorithm from trying to annotate the fresh start as a repair). The speech is not marked with any intonational information, nor is any form of punctuation inserted. The results are given in Table 4.</Paragraph>
<Paragraph position="1">  The pattern builder gives many false positives in detecting speech repairs due to word correspondences in fluent speech being mis-interpreted is evidence of a modification repair. Also, in correcting the repairs, word correspondences across an abridged repair cause the abridged repair to be interpreted as a modification repair, thus lowering the correction recall rate. 7 For example, the following abridged repair has two spurious word correspondences, between &amp;quot;need to&amp;quot; and &amp;quot;manage to&amp;quot;.</Paragraph>
<Paragraph position="2"> we need to -um manage to get the bananas to Dansville more quickly This spurious word correspondence will cause the pattern builder to hypothesize that this is a modification repair, and so propose the wrong correction.</Paragraph>
</Section>
<Section position="7" start_page="298" end_page="299" type="sub_section">
<SectionTitle>
Adding A Statistical Filter
</SectionTitle>
<Paragraph position="0"> We make use of a part-of-speech tagger to not only determine part-of-speech categories (used for deciding possible word replacements), but also to judge modification repairs that are proposed by the pattern builder. For modification repairs, the category transition probabilities from the last word of the removed text to the first word of the resumed text have a different distribution than category transitions for fluent speech. So, by giving these distributions to the part-of-speech tagger (obtained from our test corpus), the tagger can decide if a transition signals a modification repair or not.</Paragraph>
<Paragraph position="1"> editing terms when they have a sentential meanings, as in &amp;quot;I guess we should load the oranges.&amp;quot; 7About half of the difference between the detection recall rate and the correction recall rate is due to abridged repairs being mis-classified as modification repairs.</Paragraph>
<Paragraph position="2">  Part-of-speech tagging is the process of assigning to a word the category that is most probable given the sentential context (Church, 1988). The sentential context is typically approximated by only a set number of previous categories, usually one or two. Good part-of-speech results can be obtained using only the preceding category (Weischedel et al., 1993), which is what we will be using. In this case, the number of states of the Markov model will be N, where N is the number of tags. By using the Viterbi algorithm, the part-of-speech tags that lead to the maximum probability path can be found in linear time.</Paragraph>
<Paragraph position="3"> Figure 2 gives a simplified view of a Markov model for part-of-speech tagging, where Ci is a possible category for the ith word, wi, and Gi+l is a possible category for word wi+l. The category transition probability is simply the probability of category Ci+l following category Gi, which is written as P(Ci+l \]Ci). The probability of word wi+l given category Ci+l is P(wi+l ICi+l). The category assignment that maximizes the product of these probabilities is taken to be the best category assignment.</Paragraph>
<Paragraph position="4"> p(w~lCd p(w~+\]lC~+~) Figure 2: Markov Model of Part-of-Speech Tagging To incorporate knowledge about modification repairs, we let Ri be a variable that indicates whether the transition from word w~ to wi+1 contains the interruption point of a modification repair. Rather than tag each word, wi, with just a category, C~, we will tag it with Ri_lCi, the category and the presence of a modification repair. So, we will need the following probabilities, P(RiCi+1\[Ri_IC 0 and P(wiIRi_lCi). To keep the model simple, and ease problems with sparse data, we make several independence assumptions. By assuming that Ri-1 and RiCi+l are independent, given Ci, we can simplify the first probability to P(RiICi) * P(C~+I IC~Rd; and by assuming that R~_\] and wi are independent, given Ci, we can simplify the second one to P(wilCO. The model that results from this is given in Figure 3. As can be seen, these manipulations allow us to view the problem as tagging null tokens between words as either the interruption point of a modification repair, R~ = T~, or as fluent speech, R~ = C/i.</Paragraph>
<Paragraph position="5"> Modification repairs can be signaled by other indicators than just syntactic anomalies. For instance, word matches, editing terms, and word fragments also indicate their presence. This information can be added in by viewing the presence of such clues as the 'word' that is tagged by the repair indicator Ri. By assuming that these clues are independent, given the presence of a modification repair, we can simply use the product of the individual probabilities.</Paragraph>
<Paragraph position="6"> So, the repair state would have an output probability of</Paragraph>
<Paragraph position="8"> are random variables ranging over fragments, editing terms, types of word matches, respectively. So for instance, the  model can account for how &amp;quot;uh&amp;quot; is more likely to signal a modification repair than &amp;quot;um&amp;quot;. Further details are given in Heeman and Allen (1994c).</Paragraph>
</Section>
</Section>
</Paper>

