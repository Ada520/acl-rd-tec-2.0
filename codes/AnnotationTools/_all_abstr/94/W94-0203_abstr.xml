<?xml version="1.0" standalone="yes"?>

<Paper uid="W94-0203">
<Title>Constraints, Exceptions and Representations</Title>
<Section position="1" start_page="0" end_page="0" type="abstr">
<SectionTitle>
2 Buccleuch Pl., Edinburgh EH8 9LW, U.K.
</SectionTitle>
<Paragraph position="0"> raarke@cogsc+-, ed. ac. uk</Paragraph>
</Section>
<Section position="2" start_page="0" end_page="31" type="abstr">
<SectionTitle>
Abstract
</SectionTitle>
<Paragraph position="0"> This paper shows that default-based phonologies have the potential to capture morphophonological generalisations which cannot be captured by non-default theories. In achieving this result, I offer a characterisation of Underspecification Theory and Optimality Theory in terms of their methods for ordering defaults. The result means that machine learning techniques for bull(ling declm'ative analyses may not provide an adequate b~is for morphol)honological analysis.</Paragraph>
<Paragraph position="1"> Introduction In other work, I have shown (EUison 1992, forthcoming) that interesting phonological constraints can be learned despite the presence of exceptions. Each of these constraints imposes a limit the set of possible words at a common level of repre~sentation. In this paper, I consider possible limits to the usefulness of these constraints in representing morphemes and finding concise representations of lexical entries.</Paragraph>
<Paragraph position="2"> In order to compare a strictly declarative formalism with other constraint formalisms, a common formal environment must be established. Using model theory to establish the relationship between description and object, and then a modal formalism to define the structures to which constraints apply, we can compare the different effects of strict constraints and defaults. In particular, a strict declarative approach can be compared with other constraint frameworks such as Underspecification Theory (UT) (Archangeli, 1984) and ()ptimality Theory (OT) (Prince &amp; Smolensky, 1993).</Paragraph>
<Paragraph position="3"> This discussion is followed in tim latter part of the pal)or by consideration of the possibility of using machine learning to constraint systems that use defaults.</Paragraph>
<Paragraph position="4"> Morphophonology To structure the disct~ssion, I offer four desiderata for morphophonology. The first is that the morphophonology must allow concise lexical representations. Where information is predictable, it should not have to be specified in the lexicon. This desideratum is not a matter of empirical accuracy, rather one of scientific aesthetics. For example, English contains no front rounded vowels, so a vowel which is marked as front in the lexicon need not be marked as unrounded.</Paragraph>
<Paragraph position="5"> The second desideratum is that the morphophonology should allow generalisations to be made over phonologically conditioned aUomorphs. For example, a representation of the Turkish plural affixes -lar, -ler, that uses the feature \[:t:front\] is superior to a segmental representation because a single representation for the two allomorphs can be achieved by not specifying the value for this feature in the representation of the morph.</Paragraph>
<Paragraph position="6"> The third desideratum requires ttlat the specific allomorphs be recoverable from the generalisations. If-lar and -ler are generalised in a single representation, such as -IAr, then the morphophonology should make the recovery of the allomorphs in the correct environments possible.</Paragraph>
<Paragraph position="7"> The final desideratum is, like the first, a matter of scientific aesthetics: a priori abstractions should not be used in an analysis any more than is necessary. For example, the feature \[:t:front\] should not be used in the analysis of a language unless it is motivated by structures in the language itself. This desideratum may conflict with the first: a priori features may result in a more concise representation.</Paragraph>
<Paragraph position="8"> These four desiderata provide a framework for evaluating the relative merits of monostratal systems of phonological constraints with other current theories such as Underspecification Theory and Optimality Theory.</Paragraph>
<Paragraph position="9"> Model Theory and Modal Logic A fundamental distinction in any formal account is the distinction between description and object. Failure to make the distinction (:an lead, at best, to confusion, and, at worst, to paradoxes, such as Russell's Paradox.</Paragraph>
<Paragraph position="10"> Because this theory is talking about theories, it must make the distinction explicitly by formalising the relationship between description and object. This distinction is pursued in below and developed into a formalism for complex structures in the following section.</Paragraph>
<Paragraph position="11"> Model theory In model theory, the meaning of a statement in a formal l~mguage is provided by means of an INTERPRETATION  FUNCTION which maps the statement onto the set of (Jbje(:ts for which the statement is true. If L is a language and W is a set of .t)jects, and P(W) is the set of all snl)sets of W, then the interpretation function I ma.ps L onto P(W):</Paragraph>
<Paragraph position="13"> As an example, suppose &amp; is a horse, ~ is a ferret and q) is a large stone, and that these are the objects in our world. We might define a language L0 containing the terms big, animate, slow and human, and assign these terms the interpretations in (1).</Paragraph>
<Paragraph position="15"> This language can be expanded to include the logical operations of conjunction, disjunction and negation.</Paragraph>
<Paragraph position="16"> These are provided a semantics by combining the semantics of the terms they apply to.</Paragraph>
<Paragraph position="17">  (2) Term Interpretation</Paragraph>
<Paragraph position="19"> With this interpretation function, we can determine that big A animate A slow is a CONTRADICTION having a null interpretation in W, while big V slow is a TAUTO-LOGY as I(big V slow) is the same as I(big) U I(slow) which equals W.</Paragraph>
<Paragraph position="20"> The term PREDICATE will be used to describe a statement in a language which has a well-defined interpretation. null Modal logics Model theory as defined in section applies only to domains with atomic, unstructured objects. More complex structures can be captured by extending the theory of models to refer to different worlds and the relationships between them. Such a complex of worlds and relations is called a MODAL logic.</Paragraph>
<Paragraph position="21"> A modal theory consists of a universe U is a set of worlds Wj,jew, called TYPES, together with a set of relations Rk,kETC/ : Wdom(j) ~ Wcod(k ) from one world to another. Types may contain other types, and whenever a type is so contained, it defines a characteristic relation which selects elements of that subtype from the larger type. A language for this universe is more complex as well, needing a function w : L ---+ I to indicate the type W~( 0 in which any given expression l is to be interpreted. A MODAL OPERATOR rk is a special sym-I)ol in tile language which is interpreted as the relation Rk.</Paragraph>
<Paragraph position="22"> Mo(hfl operators can combine with predicates to construct new predi(:atcs. If C/ is a predicate, rk is a modal operator and w(C/) = cod(k) then we can define am interpretation, I(rkC/) C Wdom(k) , for rkC/, nanmly R~ I\[I(C/)\]. l~lrthcrmore, we define the type of the expression to be the (lomain of the fimctor: w(rkC/) = dom(k). The interpretation of any well-formed sentence in this language is a sul)set of the corresponding world I(C/) C_ W~(C/).</Paragraph>
<Paragraph position="23"> From here on, we will assume that tile Rk,ken are functions, and call the corresponding operators of the language FUNCTORS. Functors simplify the interpretation of predicates: inverses of functions preserve intersection, so functors distribute over conjunction as well as disjunction.</Paragraph>
<Paragraph position="24"> A path equation defines a predicate which selects entities that have the same result when passed through two different sequences of functions. Suppose that p and q are two sequences of functors with the same first domain and last codomain, and that the composition of the corresponding sequences of functions are P and Q respectively. Then the interpretation of p = q is the set of entities x in the common domain such that</Paragraph>
<Paragraph position="26"> Suppose the universe U consists of seven worlds, a, b, c, alphabet, nullstring, nannullstring and string.</Paragraph>
<Paragraph position="27"> Some of these worlds are built from others: alphabet is the disjoint union of a, b and c, while string is the disjoint union of nullstring and nannuUstring. Linking these types are the three functors shown in (3).</Paragraph>
<Paragraph position="28">  (3) right : nonnullstring ~ string</Paragraph>
<Paragraph position="30"> We subject these definitions to the path equation that right left x and left right x equal x for all non-null strings x.</Paragraph>
<Paragraph position="31"> A predicate in the corresponding modal language, using only the characteristic predicates of the types and the functors, might be: head a meaning the set of non-null strings whose first letter is a, left head a A right head c to specify the context a__c, or head c A right(head a A right(head b A right null)).</Paragraph>
<Paragraph position="32"> By the use of functors, we can move from one type to another, or from one item in a type to another item in the same type. Metaphorically, we will call the types joined by fimctors LOCATIONS, particularly when the type instances are only distinguished by flmctorial relationships with other types.</Paragraph>
<Paragraph position="33"> In a complex structure, like a string, the functors provide a method for interrogating nearby parts of the the structure within a predicate applying at a given position. By an appropriate choice of types and functors, complex feature structures and/or non-linear representations can be defined. For the sake of simplicity, the discussion in the remainder of this paper will be restricted to strings constructed using the types and functors defined above.</Paragraph>
<Paragraph position="35"> Constraints in a modal theory In model-theoretic terms, a constraint is any well-formed expression in the language to which an interpretation is attached. Phonologists also use the term, usually intending universal application. It will be used here for a single predicate applying at a particular location in structure.</Paragraph>
<Paragraph position="36"> As an exmnple of a constraint, consider front vowel harmony in Turkish t. Informally, we can write this constraint as if the last vowel was front, so is the current one. In the format of a phonological rule, this might be written as \[+front\]C*J~ ~ \[+front\], where C* stands for zero or more consonants. F is used to represent the disjunction of all of the front vowels.</Paragraph>
<Paragraph position="37">  (4) Left = ~ (left head C h left Left)V  left head F Constraint = head F V --,Left In (4) the left context is abstracted into a named predicate called Left. This is because the left context iterates over consonants. This iteration appears in the definition of Left as the recursive call: if the immediate left segment is a consonant, move left and check again. Left succeeds immediately if the immediate left segment is a front vowel.</Paragraph>
<Paragraph position="38"> Note the the predicate defined here imposes no restrictions at all on where it applies except that it be a non-null string. On the other hand, it only applies at the current location in structure. The relationship betwecn constraints and locations is the topic of the next section; first in the discussion of features, and then in the prioritisation of default feature assignment.</Paragraph>
<Paragraph position="39"> Features, Underspeeifieation and</Paragraph>
<Section position="1" start_page="26" end_page="27" type="sub_section">
<SectionTitle>
Defaults
</SectionTitle>
<Paragraph position="0"> The question ariscs as&amp;quot; to what basic predicates should be used in defining the lexical specification of phonological items. Lexical specifications in phonology are traditionally built from binary features. While the the feature values usually correspond to a priori predicates, there is no reason why a feature cannot be defined for an arbitrary predicate: C/ defining the feature \[+C/\] everywhere that C/ is true and \[-C/\] everywhere that C/ is false. This section includes discussion of two kinds of feature system here: A PRIORI and EXCEPTIONMARKING. null A priori features Traditionally, the choice of features is made a priori (an A Priori Feature System -- APFS). This does not mean that phonologists do not select their feature sets to suit their problems, rather that they do not approve of doing so. Instead, acoustic or articulatory grounds t &amp;quot;l~lrkish Ires eight vowels, a, e, i the back version of i, o and its front correlate 6, and u and the corresponding front vowel /i.</Paragraph>
<Paragraph position="1"> are sought for a universal set of features which will serve for all analyses.</Paragraph>
<Paragraph position="2"> Furthermore, features in traditional systems are context free. The predicates defining the features do not make reference to neighbouring structures, such as the segment to the right or the left, in order to determine the feature polarity in a given position. Feature values depend only on the segment at that position in the string.</Paragraph>
<Paragraph position="3"> Continuing to draw our examples from Turkish vowels, front can be thought of as the predicate head (eV i V 6 V fi). This predicate is context-free: there are no uses of the functors left and right in the definition.</Paragraph>
<Paragraph position="4"> We can define the feature values \[+front\] and \[-front\] as holding at each non-null position in the string where front is true and false respectively.</Paragraph>
<Paragraph position="5"> Exception-marking features A more adventurous feature system brings context together with the local segmental value to define its features. The question arises as to which predicates from this wider range should be chosen. The principle of Epicurus (Asmis, 1984) suggests that no choice should be made until direct evidence is adduced. In this domain the evidence comes in the form of a constraint on phonological structure. So, if it appears that C/ is an interesting constraint on phonological structure, then \[=t=C/\] should be used as a feature. This choice is less ad hoc than introducing new predicates a priori.</Paragraph>
<Paragraph position="6"> As an example of this kind of feature assignment, consider the constraint (4) applied to the word seviyorurn  I like (cts), which has the structure shown in (5).</Paragraph>
<Paragraph position="7"> mdl nut! T T ....</Paragraph>
<Paragraph position="8"> n-, n n ~ i~n n-n ~ n-u n.n 6---r ,., n., ,*n (5) ..... , ........</Paragraph>
<Paragraph position="9">  The features assigned by the constraint are shown in (6). For clarity, the segments and head functors are not shown. To make the clearer, the positive and negative feature marks are shown as ticks and crosses respectively. null</Paragraph>
<Paragraph position="11"> In only one case does this feature assign a negative value, ie. there is only one exception to the constraint in this word. This exception is the occurrence of the back vowel o after the front vowel i.</Paragraph>
<Paragraph position="12"> The segments themselves provide non-arbitrary context-free predicates which can be used as features.</Paragraph>
<Paragraph position="13"> For example, we could define a feature \[:t:a\] which is true if and only if head a is true.</Paragraph>
<Paragraph position="14"> These kind of feature systems are called EXCEPTION-MARKING FEATURE SYSTEMS (EMFSs) becm~se it is exceptions to identified constraints which define all but the most basic features.</Paragraph>
<Paragraph position="15">  Underspecification In EMFSs the number of features is likely to be much b~rger than in traditional systems. On the other hand, each of the features correspond to either a segment or a phonological constraint or a segment, so the system as a whole is ontologically simpler than a APFS. Nevertheless, unless some method of compression is used, EMFSs will demand verbose lexical forms. Two types of compression are familiar to, though seldom distinguished by, phonologists: redundancy and defaults 2. In terms of model theory the distinction is clear. Redundancy rules have no effect on the interpretation function I, while defaults modify it. This section discusses underspecification that eliminates redundancy. The next section discusses defaults.</Paragraph>
<Paragraph position="16"> A predicate C/ is FULLY SPECIFIED FOR another predicate C/ if either C/ is more specific than C/, that is, I(C/) = I(C/)NI(C/), or C/ contradicts C/, I(C/)f'lI(C/) = 0. A FULLY SPECIFIED predicate is one which is fully specified for all other predicates.</Paragraph>
<Paragraph position="17"> Intuitively, a fully specified predicate is one which is indivisible. There is no extra restriction which can be imposed which will make it more specific; it can only be contradicted. If C/ is a fully specified predicate, then there is no point in adding further information to it.</Paragraph>
<Paragraph position="18"> If the interpretation function I is computable, then each feature value at each position in a fully-specified structure can be calculated. If the conjunction of the feature predicate with the structure has a null interpretation, then the feature is false, otherwise it is true. Consequently, so long as a predicate remains fully specified, any feature specifications which are removed from it can be recovered.</Paragraph>
<Paragraph position="19"> In APFSs, the constraints associated with features will not be very interesting. When the features are contextual constraints, however, regaining the full specification amounts to a process of phonological derivation albeit one of simultaneous application of constraints.</Paragraph>
<Paragraph position="20"> Let us utilise the Turkish vowel set for another exampie. Suppose each vowel is assigned a feature, and so is the vowel harmony constraint, (4). For each vowel, x\[ marks the presence of the vowel, x its absence. The same symbols mean the satisfaction of a constraint or its failure. Table (7) shows redundant feature specifications with a box around them. The example word is severira I like. Features for the consonants are not shown for the sake of brevity.</Paragraph>
<Paragraph position="22"> (',l'SG-like terms feature-cooccurrence restrictions (FCi~s) ;tlld ti~ature-specification defaults (FSDs).</Paragraph>
<Paragraph position="23"> s e v e r i m</Paragraph>
<Paragraph position="25"> Note that this is not the only possible selection of redundant specifications. If the vowel feature specifications are regarded as primary and non-redundant, then the constraint feature values can all be regarded as redundant. null At this point we can define the declarative phonological formalism we are evaluating. It is an EMFS with redundant features removed, called Exception Theory (ET).</Paragraph>
</Section>
<Section position="2" start_page="27" end_page="28" type="sub_section">
<SectionTitle>
Defaults
</SectionTitle>
<Paragraph position="0"> Identifying fully specified predicates allows us to compress representations by removing predictable specifications from predicates. This compression method can be enhanced by modifying the interpretation fimction so that more predicates are fully specified.</Paragraph>
<Paragraph position="1"> A DEFAULT is defined in terms of a special predicate which will not need to be specified in individual representations. A representation will be conjoined with the default predicate unless it is already fully specified for it.</Paragraph>
<Paragraph position="2"> There may be a number of default predicates in a default system. For this reason the formal definition of the effect of defaults on the interpretation function has the recursive structure shown in (8):</Paragraph>
<Paragraph position="4"> Each default predicate specifies its action at only one position in the structure. If the default is to apply at many positions in a structure, more default predicates must be added to cover each position in the structure.</Paragraph>
<Paragraph position="5"> For example, take the default predicate ~ to be the feature \[-front\] equivalent to the predicate head (a V l V o V u). Let C/ be the partial specification for klzlam (her) girls in which each vowel is underspecified for the feature front. Then the interpretation I\[-front\](C/) of C/ subject to the default 5 applied at the location a contains only the four forms klzlam, kizlarl, k~zlari and kizlari. Forms such as kizlem are ruled out by the default at the a position.</Paragraph>
<Paragraph position="6"> To make the same default restriction at the other vowels in the word, we would need to other defaults such as left left 5 and right right 6.</Paragraph>
</Section>
<Section position="3" start_page="28" end_page="28" type="sub_section">
<SectionTitle>
Default ordering
</SectionTitle>
<Paragraph position="0"> Applying defaults is not necessarily commutative. One default may preclude ithe action of another. Consider the case where two feature values \[-front\] and \[+front\] are imposed as defaults to the completely unspecified predicate true. Because true is not fully specified for either \[-front\] or \[+front\], these defaults add specifications to the predicate: /\[-front\] (true) is I(\[-frontl) while I\[+front\](true ) is/(\[+front\]). But \[-front\] is fully specified for \[+front\] (and vice-versa), so adding \[-front\] (or \[-front\]) as a default will have no effect on the interpretation. Thus the two orderings of the defaults produce conflicting interpretations.</Paragraph>
<Paragraph position="2"> Since the two orderings produce different results, a decision about the ordering of defaults must be made.</Paragraph>
</Section>
<Section position="4" start_page="28" end_page="31" type="sub_section">
<SectionTitle>
Default Ordering Schemes
Ordering
</SectionTitle>
<Paragraph position="0"> Defimlts need to be ordered. There are a number of ways that the ordering of groups of defaults can be specified. Three of these are presented here.</Paragraph>
<Paragraph position="1"> Ordering by feature One method for ordering defaults is to order the features they instantiate. We begin with an ordering on the features, so that, for example, feature \[+F\] has higher priority than feature \[+G\], in symbols \[+F\]~\[+G\]. This ordering on features, can then be extended to an ordering on defaults specified with those features.</Paragraph>
<Paragraph position="2"> Suppose p and q are paths in string structure, composed of sequences of !eft and right functors. Then for any defaults filling in predicates 6 = p\[+F\] and e = q\[+G\], 5 is ordered before e if and only if \[+F\] has higher priority tha n \[+G\].</Paragraph>
<Paragraph position="3"> Suppose a language is analysed as imposing a higher priority default that front vowels cannot occur after round vowels. Assume that the defaults insert the features \[+front,\] and \[+round\] in all positions. Given a fi)rm kVtV where V represents the completely uninstantiated vowel, there are two different instantiations depending on the ordering of the two features. If the \[+fi'ontl default applies first, then the resulting form will be k\[+front\]t round . If, on the other hand, the \[+round\] default applies first, the derived form will be k\[+round\]t \[++ front round \] &amp;quot; Ordering by failure count Another approach orders defaults instantiating the same feature in different positions. The preferred default minimises the number of contradictions to the default feature value.</Paragraph>
<Paragraph position="4"> Suppose the default feature value to be ordered is \[+F\]. The failure count default ordering mechanism uses a default predicate for each possible number of exceptions. The predicates, 6i, are defined in (10).</Paragraph>
<Paragraph position="6"> If 5i is compatible with a predicate C/, then there is a fully-specified restriction on C/ which has no more than i occurrences of \[-F\]. The ordering on the defaults is imposed by requiring that for any feature \[+Fi\], with the corresponding predicate 6i, 5i has priority over 5j iffi &lt; j.</Paragraph>
<Paragraph position="7"> Suppose we already have a number of higher priority constraints on stress: that it can only be assigned once and in only one position within a syllable, and that consecutive syllables cannot be stressed. Collapsing the representation of syllables into a single symbol a for convenience, table (11) gives the assignment of stress to a number of partially specified representations. The default feature is \[+Stress\], and this is applied to minimise the number of failures.</Paragraph>
<Paragraph position="9"> Ordering by position Another possibility is to order defaults by how far away from the starting position they specify their features. There are two simple ways of relating distance to priority: closer means higher priority, or further away means higher priority.</Paragraph>
<Paragraph position="10"> The formal definitions for this kind of default ordering are straightforward. Suppose, once again, that \[+F\] is the feature value to be filled in by the defaults. Now, 6i will denote the specification of a default value at a distance of i functors to the left, or i to the right of the starting position.</Paragraph>
<Paragraph position="12"> To prefer near defaults, prefer Ji over 5j when i &lt; j.</Paragraph>
<Paragraph position="13"> For far defaults, do the reverse.</Paragraph>
<Paragraph position="14">  Directional default preferences minfic the application of phonological rules in a left-to-right or right-to-left direction. Using this ordering, directional defaults (:an restrict some structures which the counting defaults cannot. Consider once again the stress assignments by defaults in table (11). Instead of simply trying to maximise the number of stresses, assume that the starting position is the left end of the word, and that near stresses are given priority. Under this system of defaults, the first of the three underspecified representations is rendered more specific, while the other two make the same restriction. These results are shown in table (13).</Paragraph>
<Paragraph position="15">  Within the framework given above, it is possible to define a form of Underspecification Theory. What is described here is not precisely the Underspecification Theory of Archangeli (1984), differing in that the structures described are linear and segmental. This is, however, not a necessary limitation of the framework, and the definition of of underspecification theory presented here could be applied to autosegmental representations if suitable types and functors were defined for them.</Paragraph>
<Paragraph position="16"> In UT, lexical specifications are made in terms of an a priori fixed set of features. For example, Archangeli &amp; Pulleyblank (1989) use the four features \[+-high\], \[+-low\], \[+-back\] and \[+-ATR\] to describe seven Yoruba vowels. All lexical specifications of vowel quality are assumed to involve specifications for some subset of these features. In the lexical specifications, redundant information is left unmarked. The Yoruba vowel a does not need to be marked for any feature other than \[+low\], because there is only one vowel which is \[+low\]. Consequently, the feature values \[+back\], \[-high\] and \[-ATt~\] are all redundant.</Paragraph>
<Paragraph position="17"> In UT, redundant features are are filled by rule. Special constraints, such as the Redundancy Rule Ordering Constraint (Archangeli, 1984:85) ensure that redundancy rules apply before the features they instantiate are referred to. Furthermore, these constraints apply as often as necessary (Archangeli &amp; Pulleyblank, 1989:209-210). This has the same effect as the automatic specification of redundant feature values in the (:urrent framework.</Paragraph>
<Paragraph position="18"> Only one type of feature value is ever lexically specified in UT. Opposite feature values are filled in by default rules. This allows the feature specifications for some segments to be subspecifications of those for other se~lnelltS.</Paragraph>
<Paragraph position="19"> Apart from the context-free features used ill lexical specifications, there are also context-sensitive constraints which are regarded in UT as fiflly-fledged phonological rules. For example, the Yoruba vowel harmony rule can be summarised as a vowel on the le~t of a \[-ATR\] vowel will also be \[-ATR\]. Regularity to this constraint in one position may conflict with regularity in another position. In UT, the defaults associated with such constraints are ordered by position: Yoruba vowel harmony applies right-to-left in the sense that constraint applications further from the beginning of the word have higher priority.</Paragraph>
<Paragraph position="20"> This directionality is not the only ordering of defaults. As it happens, there are no \[+high\] vowels in Yoruba which are also \[-ATR\]. Consequently, the default rule marking vowels as \[+high\] can conflict with the default that spreads \[-ATR\]. In tim analysis of Archangeli &amp; Pulleyblank the \[+high\] default is ordered first. All defaults constructed from the one feature have priority over all defaults built on the other.</Paragraph>
<Paragraph position="21"> The general structure of UT, therefore, is to have an a priori limited set of features for lexical specification and a set of defaults for these features and for constraints. The defaults associated with each feature or constraint are ordered by position.</Paragraph>
<Paragraph position="22"> Optimality Theory Optimality Theory (Prince &amp; Smolensky, 1993) is apparently a very different theory, but, when classified in terms of its use of defaults, is actually quite similar.</Paragraph>
<Paragraph position="23"> In contrast to UT, OT is deliberately vague about underlying representations. Instead of discussing the manipulation of representations directly, OT refers to their interpretations, terming them CANDIDATE SETS.</Paragraph>
<Paragraph position="24"> Constraints in OT apply exactly like defaults. If they can be imposed without resulting in a contradiction (empty candidate set), then they are. Each constraint imposes a set of defaults, and these are primarily ordered by an extrinsic ordering placed on the constraints. If any two defaults pertaining to two constraints conflict, the default of the higher order constraint is preferred.</Paragraph>
<Paragraph position="25"> As with UT, there is the possibility that tile imposition of the the santo constraint at different locations will conflict. Rather than ordering these defaults by position, they are ordered by the number of exceptions to the constraint that they allow. If there is a candidate form with a certain number of exceptions, all candidates with more exceptions will be eliminated by the default. This ordering on defaults is the ORDERING BY FAILURE COUNT described earlier.</Paragraph>
<Paragraph position="26"> Exception Theory In contrast to the other two, more standard, phonological theories, Exception Theory does not use defaults. In ET, each lexicai form is fully specified, and any feature in it may be removed so long as this property is preserved.</Paragraph>
<Paragraph position="27"> The set of features includes a feature for each segnmnt type, and a feature for each constraint. While this results in a large set of features, underspecification of redundant features means that many feature specifications may be eliminated. Nevertheless, there will be more feature specifications needed in ET than in, for example, UT, because of the absence of default values.</Paragraph>
<Paragraph position="28"> On the other hand, because ET uses no defaults, there is no need for any form of constraint or rule ordering. All features have an immediate interpretation through the interpretation function, and so a minimum of computation is needed to identify the denotation of a representation.</Paragraph>
<Paragraph position="29"> Summary Table (14) smnmarises the attributes of the three theorivs. UT and OT are primarily distinguished by the use of different methods to order defaults built from constraints. ET differs in that it does not use defaults at all.</Paragraph>
<Paragraph position="30">  Early in this paper, four desiderata for morphophonological theories were introduced. This section considers whether using defaults is advantageous with respect to these desiderata.</Paragraph>
<Paragraph position="31"> Conciseness The first desideratum sought concise lexical representations for morphemes. Since default-based theories can also exploit underspecification of redundant feature values, they are at least as concise as non-default theories. If there are ever contrastive feature specifications, then they are more concise, allowing one side of the contrast to be left, as a default value to be instantiated.</Paragraph>
<Paragraph position="32"> Note that the concept of conciseness which is being used here is feature.counting, not an information-theoretic measure. In a direct application of information theory, contrasting a \[+F\] feature value with whitespace carries as much information as contrasting it with l-F\] 3.</Paragraph>
<Paragraph position="33"> Abstracting and recovering morphemes Defanlts also provide advantages in abstracting morpheme representations from which allomorphs can be aIt may be possible, nevertheless, to provide an information theoretic basis for the feature-counting notion by couching the feature specifications in a suitable descriptive language.</Paragraph>
<Paragraph position="34"> recovered. As well as making representations more concise, using defaults allows more allomorphs to be brought together within a single phonological representation. As there are no feature changing rules in tile framework, all feature values in the abstract representation must survive to the surface in ca.oh allom,~rl~h. Conversely, the abstract representation can only contain feature specifications common to all of the allomorphs. So the upper bound on feature specifications for the abstract morpheme is the is the intersection of the featural specifications for all of the allomorphs of the morpheme.</Paragraph>
<Paragraph position="35"> As an example, consider four allomorphs of the Turkish second person plural possessive suffix! -mxz, -iniz, -unuz and -ilniiz. If the vowels are specified with the three features \[=Lfront\], \[:t:round\] and \[+-high\], then the iatersection of the specificati(ms of the four alh)m(~rl~hs is the sequence \[+high\]n\[+high\]z.</Paragraph>
<Paragraph position="36"> While it is always possible to form abstract representations by intersecting feature values (the second desideratum), there is no guarantee that the allomorphs will be readily recoverable (third desideratum). If they are not recoverable, then there is no single featural generalisation which captures the phonological structure of the morphemes.</Paragraph>
<Paragraph position="37"> One important question is whether defaults allow recoverable generalisations about a greater range of morphemes than non-default representations. The answer is yes. If the morphological alternations is onedimensional, then there is no difference between having defaults and not. Suppose 5 is a default predicate, and, equally, an exception feature. If all allomorphs are specified \[+~\] then the abstraction will share this feature, and so the default does not need to apply. Similarly if all allomorphs are specified \[-6\], so will the abstract forms be, and the default cannot apply. If the allomorphs vary in their specification for \[+-5\], then the abstraction will not have include a specification for this feature. Consequently, the default will specify \[+J\] when the correct value is l-J\], and so not fail to produce the correct result. In the non-default interpretation, the representation is never fully specified.</Paragraph>
<Paragraph position="38"> On the other hand, if the morphological alternations form a two-dimensional paradigm, then it is possible that the paradigm might be decomposable into morphemes only with the use of defaults. Suppose, once again, that J is a default predicate and exception feature. The default feature value is \[+5\]. Suppose further, that there is a paradigm with the feature specification for \[:t=5\] shown in (15).</Paragraph>
<Paragraph position="39">  The margins show the 'morphemes' extracted by intersecting the feature values. The conjunction of the two \[05\] specifications is not fully specified for 5, and so its direct interpretation does not recover the corresponding  component of the paradigm. If, however, the default \[+6\] is applied, the full specification of the paradigm is recovered.</Paragraph>
<Paragraph position="40"> So it is possible to have paradigms where the morphological components cannot be assigned common phonological representations without the use of defaults 4. A priori specifications The final desideratum is the avoidance of a priori information in a model. UT makes use of an a priori set of features for lexical specification. As other generalisations in the formalism are only visible insofar as they affect the values of these features, this limits the possible constraints which can be identified. This is the reason why vowel harmonies such as that of Nez Perce are so problematic for phonologistsS: the sets of vowels used in the harmony do not have a neat definition in terms of traditional features.</Paragraph>
<Paragraph position="41"> Greater claims about a priori features are made in OT. Prince &amp; Smolensky (1993:3) state that constraints are essentially universal and of very general formulation ... interlinguistic differences arise from the permutation of constraint-Tunking. In other words, all of the predicates which define features in OT are prior to the analysis of an individual language.</Paragraph>
<Paragraph position="42"> In ET, very little is assumed a priori. Any constraint which captures interesting phonological generalisations about the phonology defines a feature which can be used to specify structure. Because ET does not use defaults, it need not be concerned with ordering constraints, only with finding them. Consequently, interlinguistic differences can only result from distinct sets of constraints. Conclusion In this paper I have presented a rigorous framework for characterising theories that use defaults with phonological structure. The framework provides a straightforward characterisation of Underspecification Theory and Optimality Theory in terms of the action of defaults.</Paragraph>
<Paragraph position="43"> Using this framework, I have shown that non-defanlt theories cannot be sure of capturing all of the generalisations which are available to default theories. For this reason, the non-default constraints learnt by programs suctl as ttmse described by Ellison (1992, forthconfing), are not as powerful for morphophonological analysis as default-based theories. Furthermore, defaults lead to more concise, and consequently preferable, lexical representations. null 4If general predicates are permitted for specifying morphemes, rather than just featural specifications, the distinction between default and non-default systems disappears. If the entries in the l)aradigm are ~ij, define o~i to be Vj ~ij a.ml fl.j I.o be Ai((ij V &amp;quot;~,~i). Then, s(, long as |,ll~ t~i are disi,im:t (wiiich will l)e tim case if the (i.i are all distinct), then the i)~tradigm will be fully recoverable without defaults. 5Anderson &amp; Durand (1988) discuss some of this literature.</Paragraph>
<Paragraph position="44"> The question, therefore, is how to enhance the learning algorithms to involve the use of defaults. The introduction of defaults means that constraints must be ordered; so learning must not only discover the right constraint, it must assign it a priority relative to other constraints. This makes the learning task consideral)le more complicated. However difficult a solution for this problem is to find, it will be necessary before m~u:hincgenerated analyses can be sure of competing successfully with man-made analyses.</Paragraph>
</Section>
</Section>
</Paper>

