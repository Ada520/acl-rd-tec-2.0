<?xml version="1.0" standalone="yes"?>

<Paper uid="J89-2004">
<Title>Technical Correspondence On the Logic of Category Definitions ON THE LOGIC OF CATEGORY DEFINITIONS</Title>
<Section position="1" start_page="0" end_page="0" type="abstr">
<SectionTitle>
ON THE LOGIC OF CATEGORY DEFINITIONS
</SectionTitle>
<Paragraph position="0"> In their paper on category structures, Gazdar et al.</Paragraph>
<Paragraph position="1"> (1988) define a constraint language L c for categories and a logic A c of admissible category structures. ~ The intuitive idea is that for a constraint $ expressed in L c, ~b is a nontrivial constraint if and only if A c 14 th; and it is a satisfiable constraint if and only if Ac 14 -nth. From a practical point of view it is therefore important to know whether A c is decidable and even better that the decision can be given in a time bounded by a recursive function on the length of ~b. However, the remarks made in their paper only suffice to show that the modal fragment of Ac 2 contains S4.Grz = K(l-lp --&gt; p, C\]p --* DDp, \[~(D(p --* Dp) --* p) --~ p), which does not show that this fragment is decidable. In this note, I will establish both that the modal fragment of A c and A c itself are decidable, and I will prove it in that order. As a result, I will also axiomatize A c. Thus I show first that the modal reduct of Ac, which I call AM, is decidable.</Paragraph>
<Paragraph position="2"> This paper will be rather hardgoing for anyone not acquainted with modal logic. We advise the reader to have Gazdar et al. (1988) at hand while reading this paper, or better still, to read it once through beforehand. For the modal logics we refer the reader to Boolos (1979), Harel (1984), and Segerberg (1971), but in principle any introduction to modal logic will provide enough background to be able to understand the gist of the arguments.</Paragraph>
<Paragraph position="3"> Without going into too many details of the construction, I will show that there is an easy way to give a proof that in fact shows that A M = S4.Grz using the structure of the models those logics admit. Intuitively, categories correspond to Kripke models. For let a be a category.</Paragraph>
<Paragraph position="4"> Then a defines a set of categories W, which is obtained by successively applying type 13 features to a. An accessibility relation &lt;1 is defined via ot &lt;1/3 ifffla) =/3 for some type 1 feature f. This accessibility relation is irreflexive, intransitive, finite, and defines a tree-structure on W. Most importantly, it is cycle free. Thus, if we look at the reflexive and transitive closure &lt;\]+ of &lt;1, it is again finite and has no non-trivial cycles. It therefore is an S4.Grz structure (see, e.g., Boolos 1979). Conversely, an S4.Grz structure &lt;W, &lt;\]+&gt; which is a tree can be represented as a category. If we then take a model &lt;W, &lt;1 +, val&gt; based on that frame, where val: X--~ 2 w maps a finite set of propositional variables into 2 w, we can code this model by adding a type 0 featurefp for each p ~ X that takes values Y or +-. Thus the resulting category t~ not only codes the successor function by means of type I features, but also the valuation val. W is in one-to-one correspondence ~b with the set F of categories generated by a. We then make the following definitions: Let/3 be in F: i./3 ~ fp : Tiff ~/3) E val(p) iff ~/3) ~ p ii. \[3 ~ fp : +- iff qb(/3) ~ val(p) iff ~/3) ~ -p It is easy to see that for any modal formula P with variables in X, the corresponding translation ~&amp;quot; induced by p *-~ fp : T satisfies/3 ~ &amp;quot;t(P) iff q~(/3) ~ P. The logic of &lt;W,&lt;\]+&gt; therefore coincides with the logic of all categories that differ from ot only in the assignment of type 0 features. To conclude, the logic of categories as defined in Gazdar et al. (1988) coincides with the logic of all finite, reflexive, transitive trees. It is easily seen that the finite, reflexive, transitive trees generate the class of finite models for S4.Grz. Thus the logic of categories is the logic of the finite models of S4.Grz which, since S4.Grz has the finite model property, is identical to S4.Grz (end ofproojO.</Paragraph>
<Paragraph position="5"> A few remarks are in order: I. I used a purely semantical argument, which in this case is the most direct way, because it is fairly easy to see why we get just the models we get,  though there is some footwork to be done.</Paragraph>
<Paragraph position="6"> 2. Alternatively I could have built a canonical model out of a category structure X, whose worlds are the categories that X admits and whose accessibility relation is as defined above for categories. The proof is essentially the same.</Paragraph>
<Paragraph position="7"> 3. The idea of encoding frames and valuations into a single structure has also been explored in Fagin (1985).</Paragraph>
<Paragraph position="8"> 4. In Rautenberg (1983) a simple tableau calculus for  S4.Grz is given which shows that S4.Grz consistency is effectively decidable, and that the decision procedure is primitive recursive. Furthermore, the size of a tableau is bounded by a function of the number o~P) of subformulas of P, or, more precisely, the theoremhood of P can be decided with a tableau of length -&lt; 27+60(P). Given the proof, the same holds for A M , since the translation procedure reduces the size of a formula. So we have the same bound for A c.</Paragraph>
<Paragraph position="9"> 5. In Gazdar et al. (1988) another logic is mentioned which arises from restricting the number of type 1 features to 1. The resulting logic is equal to</Paragraph>
<Paragraph position="11"> linear orders, as can be seen in the same way.</Paragraph>
<Paragraph position="12"> Since finitely generated S4.3.Grz models are finite, this logic is decidable as well.</Paragraph>
<Paragraph position="13"> I will now proceed to the full case. Before I embark on the proof, let me remark on a few things. First, although each particular category structure contains only a finite number of features and values, L c contains infinitely many of them. As regards the type 0 features, this causes no problem, since we treatf : a as a proposition and we allow ourselves infinitely many of those. However, type 1 features will create some problems that are not very serious but have to be dealt with carefully.</Paragraph>
<Paragraph position="14"> Second, as we defined a translation of L c into modal logic, we will now define a translation of L c into elementary propositional dynamic logic (EPDL) so that every type 1 feature has a program associated with it Computational Linguistics, Volume 15, Number 2, June 1989 0362-613X/89/010111-113-$03.00 111 Technical Correspondence On the Logic of Category Definitions whose interpretation is an accessibility relation between categories. This translation is harmless and allows us to forget about type 0 features altogether.</Paragraph>
<Paragraph position="15"> i. ,(f : a) = P&lt;f:a&gt; wherefis of type 0 ii. &amp;quot;t~,. : ~b) = &lt;7,.&gt; ~b where f; is of type 1 iii. \[~b = \[a\]~b a is a program that by definition contains all other programs; that is, if two categories are related by 3&amp;quot;~, they are also related by a. However, although the intuition is that a is the reflexive and transitive closure of all the y;'s, this fact is not expressible in EPDL nor in L c because it requires a formula of infinite length. But, as it turns out, this is a harmless deficiency of our language. The translation of A c into EPDL will be called _.</Paragraph>
<Paragraph position="16"> I will now give a full axiomatization of'_ =. As we saw earlier, the axioms governing the behaviour of \[a\] are exactly the axioms for S4.Grz, since \[a\] is the old 71.</Paragraph>
<Paragraph position="17"> Similar reasoning will reveal that the \[3'~\] behave alike, and the corresponding logic is the logic otherwise known as K.AIt~, which stands for &amp;quot;only one alternative&amp;quot;. The accessibility relation for K.AI h allows a world to have at most one successor. Although it has more models, K.AIh is the logic of all irreflexive, linear and finite frames, which shows that it is the logic we are looking for. If we take all this together with the observation that a includes 3&amp;quot;i, we get the following axioms</Paragraph>
<Paragraph position="19"> Note that -= is not finitely axiomatizable and so A c isn't either. Note also that if it weren't for the axiom(s) called Mix, life would be very easy for us now. Since the axioms for the various programs are independent, the finite model property for each of those programs individually would yield the finite model property for the whole logic by simple induction on the number of programs. Thus let us call the logic without Mix ,-e.</Paragraph>
<Paragraph position="20"> Also, since we have a tableau calculus for S4.Grz and a tableau calculus for K.AIh, we have a calculus for -=e as well, simply by putting all tableau rules together. The tableau rule for 3'; would look as follows: from F; &lt;yi &gt; 4~ step to Fdeg; ~b, where F deg := {q~ I &lt;3';&gt; ~0 ~ F or \[3'~\]~0 F}. I shall spare the reader an exact specification of the tableau rules and refer him to Rautenberg (1983) again. Note that the length of the tableaus for K.AIh is bounded by the size of ~b so that the actual size of the tableau is at most 2 ~deg~'), where n is the length of ~b and o(th) the number of subformulas of ~b. This bound could be sharpened somewhat but we ignore this point. What I want to show is how the fact that -=e can be shown to have all those properties can be made to explain why -= must have those properties, too. What the reader should understand at this point is that tableaus are a way of systematically constructing a model for a formula (if it is consistent) and showing inconsistency by exhausting all possible choices, of which there are only finitely many.</Paragraph>
<Paragraph position="21"> What I do now is boost up a model construction procedure for =e to a model construction procedure for -=. This is done as follows: Suppose we want to construct a E-model for $. Since we do not know how to do this we construct a -=e-model instead. However, this model might be deficient by not respecting Mix. Therefore we add a finite set ~b # of instances of Mix which will ensure that Mix is respected for subformulas of ~b. The =e model can then safely be turned into an -= model.</Paragraph>
<Paragraph position="22"> Let me therefore define the modal degree d of a formula.</Paragraph>
<Paragraph position="24"> Furthermore, let sf(&amp;) be the set of subformulas of ~b.</Paragraph>
<Paragraph position="25"> Then define</Paragraph>
<Paragraph position="27"> Then we say that an _= tableau for &amp; is simply an =e tableau for ~b;$ #. Let us see how &amp;# makes everything right for us. The failure of -=e is to allow models for &lt;7i &gt; 1\]1 /~ \[t~\]--'l~/. For suppose we build a simple =e tableau tbr 4, and we encounter a line F; &lt;3&amp;quot;;&gt; q,A \[a\]-n4,. In the next step we get F; &lt;7;&gt; q,;\[a\]TqJ and then Fdeg;qJ.</Paragraph>
<Paragraph position="28"> But if we added ~b #, then F would necessarily contain a formula yielding &lt;3,;&gt; qJ---~ &lt;a&gt; qJ, which would close this branch of the tableau. Thus an =e tableau for ~b;~b # results in a model &lt;W, &lt;3, val&gt; in which, though a is an independent program, for every subformula qJ of ~b, if s,val ~&lt;3,;&gt; ~0, then also s,val ~&lt;a&gt; q~. Thus it is easy to see that if we now reinterpret the a relation &amp;quot;~ as the reflexive, transitive closure of a and the 3'g, we get an -= model &lt; W, &lt;3, val&gt; for ~b, which obviously is of the same size. Thus, if _e has the finite model property, -= has the finite model property, and if the decision procedure for _e is bounded a priori by a function on the length of ~b, the same holds for _=. Obviously, the bound is much higher than for -=o because of the 4, #, but this is the price we have to pay (end ofproojO.</Paragraph>
<Paragraph position="29"> Given the above proof we can now change the tableau calculus for -= by redefining the rule for 3&amp;quot;i to the following: from F; &lt;7/&gt; ~b infer Fdeg; FD;~b where F deg := {qJ \[ &lt;y~&gt; qJ E F or \[3';\]q, E F} and F D := {\[a\]~ \[ \[a\]~ F} O {~0 \[ \[a\]qJ ~ F}. The proof method I used for proving decidability for -= (Ac) from the decidability of =e is explained in full detail in Kracht (1988). The same method applies to the case when we only allow a single type I feature, since it only requires the base logic--in 112 Computational Linguistics, Volume 15, Number 2, June 1989 Technical Correspondence On the Logic of Category Definitions this case S4.3.Grzuto have the finite model property.</Paragraph>
<Paragraph position="30"> The resulting logic -=.3 can be (finitely) axiomatized as follows:  The model construction requires some care since we do not have an unlimited resort of extra features, but it can be done in the same spirit. This shows decidability for ,=.3 and hence for the corresponding logic mentioned in the paper. An alternative formulation of -=.3 could be given with the help of propositional dynamic logic using the star operator *. We would then simply have an axiom &lt;y~'&gt; 4&gt; ~ &lt;a&gt; 4&gt; that says nothing else, but that a is the reflexive and transitive closure of TI. This trick would also work if we restrict _ to any finite number of features. But the star does not gain us much for -= itself since we still could not express the fact that a is the reflexive and transitive closure of the yi's because we have infinitely many of them.</Paragraph>
</Section>
</Paper>

