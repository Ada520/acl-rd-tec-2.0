<?xml version="1.0" standalone="yes"?>

<Paper uid="P91-1011">
<Title>EFFICIENT INCREMENTAL PROCESSING WITH CATEGORIAL GRAMMAR</Title>
<Section position="1" start_page="0" end_page="85" type="abstr">
<SectionTitle>
EFFICIENT INCREMENTAL PROCESSING WITH CATEGORIAL GRAMMAR
Abstract
</SectionTitle>
<Paragraph position="0"> Some problems are discussed that arise for incremental processing using certain flezible categorial grammars, which involve either undesirable parsing properties or failure to allow combinations useful to incrementality. We suggest a new calculus which, though 'designed' in relation to categorial interpretatious of some notions of dependency grammar, seems to provide a degree of flexibility that is highly appropriate for incremental interpretation. We demonstrate how this grammar may be used for efficient incremental parsing, by employing normalisation techniques.</Paragraph>
<Paragraph position="1"> Introduction A range of categorial grammars (CGs) have been proposed which allow considerable flexibility in the assignment of syntactic structure, a characteristic which provides for categorial treatments of extraction (Ades &amp; Steedman, 1982) and non-constituent coordination (Steedman, 1985; Dowty, 1988), and that is claimed to allow for incremental processing of natural language (Steedman, 1989). It is this latter possibility that is the focus of this paper.</Paragraph>
<Paragraph position="2"> Such 'flexible' CGs (FCGs) typically allow that grammatical sentences may be given (amongst others) analyses which are either fully or primarily leftbranching. These analyses have the property of designating many of the initial substrings of sentences as interpretable constituents, providing for a style of processing in which the interpretation of a sentence is generated 'on-line' as the sentence is presented.</Paragraph>
<Paragraph position="3"> It has been argued that incremental interpretation may provide for efficient language processing -- by both humans and machines -- in allowing early filtering of thematically or referentially implausible readings. The view that human sentence processing is 'incremental' is supported by both introspective and experimental evidence.</Paragraph>
<Paragraph position="4"> In this paper, we discuss FCG approaches and some problems that arise for using them as a basis for incremental processing. Then, we propose a grammar that avoids these problems, and demonstrate how it may be used for efficient incremental processing.</Paragraph>
<Paragraph position="5">  New Museums Site, Pembroke St, Cambridge, UK.</Paragraph>
<Paragraph position="6"> e-mail : mrhQuk, aC/. cam. C/i</Paragraph>
<Section position="1" start_page="0" end_page="80" type="sub_section">
<SectionTitle>
Flexible Categorial Grammars
</SectionTitle>
<Paragraph position="0"> CGs consist of two components: (i) a categorial lexicon, which assigns to each word at least one syntactic type (plus associated meaning), (ii) a calculus which determines the set of admitted type combinations and transitions. The set of types (T) is defined recursively in terms of a set of basic types (To) and a set of operators (\ and/, for standard bidirectional CG), as the smallest set such that (i) To C T, (ii) if x,y E T, then x\y, x/y E T. 1 Intuitively, lexical types specify subcategorisation requirements of words, and requirements on constituent order. The most basic (non-flexible) CGs provide only rules of application for combining types, shown in (1). We adopt a scheme for specifying the semantics of combination rules where the rule name identifies a function that applies to the meanings of the input types in their left-to-right order to give the meaning of the result expression.</Paragraph>
<Paragraph position="1">  (1) f: X/Y + Y =~ X (where f= AaAb.(ab)) b: Y + X\Y =~ X (where b = AaAb.(ba))  The Lambek calculus We begin by briefly considering the (product-free) Lambek calculus (LC - Lambek, 1958). Various formulations of the LC are possible (although we shall not present one here due to space limitations). 2 The LC is complete with respect to an intuitively sensible interpretation of the slash connectives whereby the type x/y (resp. x\y) may be assigned to any string z which when left-concatenated (resp. rightconcatenated) with any string y of type y yields a string x.y (resp. y.x) of type x. The LC can be seen to provide the limit for what are possible 1 We use a categorial notation in which x/y and x\y are both functions from y into x, and adopt a convention of left association, so that, e.g. ((s\np)/pp)/np may be written s\np/pp/np.</Paragraph>
<Paragraph position="2"> 2See Lambek (1958) and Moortgat (1989) for a sequent formulation of the LC. See Morrill, Leslie, Hepple &amp; Barry (1990), and Barry, Hepple, Leslie &amp; Morrill (1991) for a natural deduction formulation. Zielonka (1981) provides a LC formulation in terms of (recursively defined) reduction schema. Various extensions of the LC are currently under investigation, although we shall not have space to discuss them here. See Hepple (1990), Morrill (1990) and Moortgat (1990b).  type combinations -- the other calculi which we consider admit only a subset of the Lambek type combinations, s The flexibility of the LC is such that, for any combination xl,..,x, ==~ x0, a fully left-branching derivation is always possible (i.e. combining xl and x2, then combining the result with x3, and so on). However, the properties of the LC make it useless for practical incremental processing. Under the LC, there is always an infinite number of result types for any combination, and we can only in practice address the possibility of combining some types to give a known result type. Even if we were to allow only S as the overall result of a parse, this would not tell us the intermediate target types for binary combinations made in incrementally accepting a sentence, so that such an analysis cannot in practice be made.</Paragraph>
<Paragraph position="3"> Comblnatory Categor|al GrRmmar Combinatory Categorial Grammars (CCGs - Steedman, 1987; Szabolcsi, 1987) are formulated by adding a number of type combination and transition schemes to the basic rules of application. We can formulate a simple version of CCG with the rules of type raising and composition shown in (2). This CCG allows the combinations (3a,b), as shown by the proofs (4a,b).</Paragraph>
<Paragraph position="4">  (2) T: x ::~ y/(y\x) (where T - AxAf.(fz)) B: x/y + y/z =:~ x/z (where B = (3) a. np:z, s\np/np:f =~ s/np:Ay.fyz b. vp/s:f, np:z =~ vp/(s\np):Ag.f(gz) (4) (a) np s\np/np (b) vp/s np T T</Paragraph>
<Paragraph position="6"> The derived rule (3a) allows a subject NP to combine with a transitive verb before the verb has combined with its object. In (3b), a sentence embedding verb is composed with a raised subject NP.</Paragraph>
<Paragraph position="7"> Note that it is not clear for this latter case that the combination would usefully contribute to incremental processing, i.e. in the resulting semantic expression, the meanings of the types combined are not directly related to each other, but rather a hypothetical function mediates between the two. Hence, any 3In some frameworks, the use of non-Lambek-valid rules such as disharmonic composition (e.g. x/y + y\z ::~ x\z) has been suggested. We shall not consider such rules in this paper.</Paragraph>
<Paragraph position="8"> requirements that the verb may have on the semantic properties of its argument (i.e. the clause) could not be exploited at this stage to rule out the resulting expression as semantically implausible. We define as contentful only those combinations which directly relate the meanings of the expressions combined, without depending on the mediation of hypothetical functions.</Paragraph>
<Paragraph position="9"> Note that this calculus (like other versions of CCG) fails to admit some combinations, which are allowed by the LC, that are contentful in this sense -- for example, (5). Note that although the semantics for the result expression in (5) is complex, the meanings of the two types combined are still directly related -- the lambda abstractions effectively just fulfil the role of swapping the argument order of the subordinate functor.</Paragraph>
<Paragraph position="10"> (5) x/(y\z):f, y/w\z:g ~ x/w:Av.f(Aw.gwv) Other problems arise for using CCG as a basis for incremental processing. Firstly, the free use of type-raising rules presents problems, i.e. since the rule can always apply to its own output. In practice, however, CCG grammars typically use type specific raising rules (e.g. np =~ s/(s\np)), thereby avoiding this problem. Note that this restriction on type-raising also excludes various possibilities for flexible combination (e.g. so that not all combinations of the form y, x\y/z =~ x/z are allowed, as would be the case with unrestricted type-raising).</Paragraph>
<Paragraph position="11"> Some problems for efficient processing of CCGs arise from what has been termed 'spurious ambiguity' or 'derivational equivalence', i.e. the existence of multiple distinct proofs which assign the same reading for some combination of types. For example, the proofs (6a,b) assign the same reading for the combination. Since search for proofs must be exhaustive to ensure that all distinct readings for a combination are found, effort will be wasted constructing proofs which a....~ ~he same meaning, considerably reducing the elficiency of processing.</Paragraph>
<Paragraph position="12"> Hepple &amp; Morrill (1989) suggest a solution to this problem that involves specifying a notion of normal form (NF) for CCG proofs, and ensuring that the parser returns only NF proofs. 4 However, their method has a number of limitations. (i) They considered a 'toy grammar' involving only the CCG rules stated above. For a grammar involving further combination rules, normalisation would need to be completely reworked, and it remains to be shown that this task can be successfully done. (ii)  The NF proofs of this system are right-branching -- again, it remains to be shown that a NF can be defined which favours left-branching (or even primarily left-branching) proofs.</Paragraph>
<Paragraph position="13">  (6) (a) x/y y/z - (b) x/y y/z f B</Paragraph>
<Paragraph position="15"></Paragraph>
</Section>
<Section position="2" start_page="80" end_page="80" type="sub_section">
<SectionTitle>
Meta-Categorial Grammar
</SectionTitle>
<Paragraph position="0"> In Meta-Categorial Grammar (MCG - Morrill, 1988) combination rules are recursively defined from the application rules (f and b) using the metarnles (7) and (8). The metarules state that given a rule of the form shown to the left of ==~ with name ~, a further rule is allowed of the form shown to the right, with name given by applying tt or L to C/ as indicated. For example, applying It to backward application gives the rule (9), which allows combination of subject and transitive verb, as T and B do for CCG. Note, however, that this calculus does not allow any 'non-contentful' combinations -- all rules are recursively defined on the application rules which require a proper functional relation between the types combined. However, this calculus also fails to allow some contentful combinations, such as the case x/(y\z), y/w\z =:~ x/w mentioned above in (5). Like CCG, MCG suffers from spurious ambiguity, although this problem can be dealt with via normalisation (Morrill, 1988; Hepple &amp; Morrill,</Paragraph>
</Section>
<Section position="3" start_page="80" end_page="85" type="sub_section">
<SectionTitle>
The Dependency Calculus
</SectionTitle>
<Paragraph position="0"> In this section, we will suggest a new calculus which, we will argue, is well suited to the task of incremental processing. We begin, however, with some discussion of the notions of head and dependent, and their relevance to CG.</Paragraph>
<Paragraph position="1"> The dependency grammar (DG) tradition takes as fundamental the notions of head, dependent and the head-dependent relationship; where a head is, loosely, an element on which other elements depend.</Paragraph>
<Paragraph position="2"> An analogy is often drawn between CG and DG based on equating categorial functors with heads, whereby a functor x/yl../yn (ignoring directionality, for the moment) is taken to correspond to a head requiring dependents Yl..Yn, although there are several obvious differences between the two approaches. Firstly, a categorial functor specifies an ordering over its 'dependents' (function-argument order, that is, rather than constituent order) where no such ordering is identified by a DG head. Secondly, the arguments of a categorial functor are necessarily phrasal, whereas by the standard view in DG, the dependents of a head are taken to be words (which may themselves be heads of other head/dependent complexes). Thirdly, categorial functors may specify arguments which have complex types, which, by the analogy, might be described as a head being able to make stipulations about the dependency requirements of its dependent and also to 'absorb' those dependency requirements. 5 For example, a type x/(y\z) seeks an argument which is a &amp;quot;y needing a dependent z&amp;quot; under the head/functor analogy. On combining with such a type, the requirement &amp;quot;need a dependent z&amp;quot; is gone. Contrast this with the use of, say, composition (i.e. x/y, y/z =~ x/z), where a type x/y simply needs a dependent y, and where composition allows the functor to combine with its dependent y while the latter still requires a dependent z, and where that requirement is inherited onto the result of the combination and can be satisfied later on.</Paragraph>
<Paragraph position="3"> Barry &amp; Pickering (B&amp;P, 1990) explore the view of dependency that arises in CG when the functor-argument relationship is taken as analogous to the traditional head-dependent relationship. A problem arises in employing this analogy with FCGs, since FCGs permit certain type transformations that undermine the head-dependent relations that are implicit in lexical type assignments. An obvious example is the type-raising transformation x =~ y/(y\x), which directly reverses the direction of the head-dependent relationship between a functor and its argument. B&amp;P identify a subset of LC combinations as dependency preserving (DP), i.e. those combinations which preserve the head-dependent relations implicit in the types combined, and call constituents which have DP analyses dependency constituents. B&amp;P argue for the significance of this notion of constituency in relation to the treatment of coordination and the comparative difficulty observed for (human) processing of nested and non5Clearly, a CG where argument types were required to be basic would be a closer analogue of DG in not allowing a 'head' to make such stipulations about its dependents. Such a system could be enforced by adopting a more restricted definition of the set of types (T) as the smallest set such that (i) To C T, (ii) if x E T and y E To, then x\y, x/y E T (c.f. the definition given earlier).</Paragraph>
<Paragraph position="4">  nested constructionsfi B&amp;P suggest a means for identifying the DP subset of LC transformations and combinations in terms of the lambda expressions that assign their semantics. Specifically, a combination is DP iff the lambda expression specifying its semantics does not involve abstraction over a variable that fulfils the role of functor within the expression (c.f. the semantics of type raising in (2))ff We will adopt a different approach to B&amp;P for addressing dependency constituency, which involves specifying a calculus that allows all and only the DP combinations (as opposed to a criterion identifying a subset of LC combinations as DP). Consider again the combination x/(y\z), y/w\z =~ x/w, not admitted by either the CCG or MCG stated above. This combination would be admitted by the MCG (and  also the CCG) if we added the following (Lambekvalid) associativity axioms, as illustrated in (11). (10) a: x\y/z=~x/z\y a: x/y\z=~x\z/y</Paragraph>
<Paragraph position="6"> We take it as self-evident that the unary transformations specified by these two axioms are DP, since function-argument order is a notion extraneous to dependency; the functors x\y/z and x/z\y have the same dependency requirements, i.e. dependents y and z. s For the same reason, such reordering of arguments should also be possible for functions that occur as subtypes within larger types, as in (12a,b). The operation of the associativity rules can be 'generalised' in this fashion by including the unary metarules (13), 9 which recursively define eSee Baxry (forthcoming) for extensive discussion of dependency and CG, and Pickering (1991) for the relevance of dependency to human sentence processing.</Paragraph>
<Paragraph position="7"> 7B&amp;P suggest a second criterion in terms of the form of proofs which, for the natural deduction formulation of the LC that B&amp;P use, is equivalent to the criterion in terms of laznbda expressions (given that a variant of the Curry-Howard correspondence between implicational deductions and lambda expressions obtains).</Paragraph>
<Paragraph position="8"> s Clearly, the reversal of two co-directional arguments (i.e. x/y/z =~ x/z/y) would also be DP for this reason, but is not LC-valld (since it would not preserve linear order requirements). For a unidirectional CG system (i.e. a system with a single connective/, that did not specify linear order requirements), free reversal of axguments would be appropriate. We suggest that a unidirectional variant of the calculus to be proposed might be the best system for pure reasoning about 'categorial dependency', aside from linearity considerations.  9These unary metarules have been used elsewhere as part of the LC formulation of Zielonka (1981).</Paragraph>
<Paragraph position="9"> new unary rules from tile associat, ivit.) axioms.</Paragraph>
<Paragraph position="10"> (12) a. a\b/c/d ~ a/ckb/d b. x/(a\b/c) ~ x/Ca/c\b) (13) a. C/: x=~y ==~ VC/: x/z ::~y/z  Clearly, the rules {V,Z,a} allow only DP unary transformations. However, we make the stronger claim that these rules specify the limit of DP unary transformations. The rules allow that the given functional structure of a type be 'shuffled' upto the limit of preserving linear order requirements. But the only alternative to such 'shuffling' would seem to be that some of the given type structure be removed or further type structure be added, which, by the assumption that functional structure expresses dependency relations, cannot be DP.</Paragraph>
<Paragraph position="11"> We propose the system {L,R,V,Z,a,f,b} as a calculus allowing all and only the DP combinations and transformations of types, with a 'division of labour' as follows: (i) the rules f and b, allowing the establishment of direct head-dependent relations, (ii) the subsystem {V,Z,a}, allowing DP transformation of types upto the limit of preserving linear order, and (iii) the rules tt and L, which provide for the inheritance of 'dependency requirements' onto the result of a combination. We call this calculus the dependency calculus (DC) (of which we identify two subsystems: (i) the binary calculus B : {L,R,f,b}, (ii) the unary calculus U : {V,Z,a}). Note that B&amp;P's criterion and the DC do not agree on what are DP combinations in all cases. For example, the semantics for the type transformation in (14) involves abstraction over a variable that occurs as a functor.</Paragraph>
<Paragraph position="12"> Hence this transformation is not DP under B&amp;P's criterion, although it is admitted by the DC. We believe that the DC is correct in admitting this and the other additional combinations that it allows.</Paragraph>
<Paragraph position="13"> There is clearly a close relation between DP type combination and the notion of contentful combination discussed earlier. The 'dependency requirements' stated by any lexical type will constitute the sum of the 'thematically contentful' relationships into which it may enter. In allowing all DP combinations (subject to the limit of preserving linear order requirements), the DC ensures that lexieally  originating dependency structure is both preserved and also exploited in full. Consequently, the DC is well suited to incremental processing. Note, however, that there is some extent of divergence between the DC and the (admittedly vague) criterion of 'contentful' combination defined earlier. Consider the LC-valid combination in (15), which is not admitted by the DC. This combination would appear to be 'contentful' since no hypothetical semantic functor intervenes between land g (although g has undergone a change in its relationship to its own argument which depends on such a hypothetical functor). However, we do not expect that the exclusion of such combinations will substraet significantly from genuinely useful incrementality in parsing actual grammars.</Paragraph>
<Paragraph position="14"> (15) x/(y/z):/, x:l(X .g(Xh.hv)) Parsing and the Dependency Calculus Binary combinations allowed by the DC are all of the form (16) (where the vertical dots abbreviate unary transformations, and C/ is some binary rule). The obvious naive approach to finding possible combinations of two types x and y under the DC involves searching through the possible unary transforms of x and y, then trying each possible pairing of them with the binary rules of B, and then deriving the set of unary transforms for the result of any successful combination.</Paragraph>
<Paragraph position="15"> At first sight, the efficiency of processing using this calculus seems to be in doubt. Firstly, the search space to be addressed in checking for possible combinations of two types is considerably greater than for CCG or MCG. Also, the DC will suffer spurious ambiguity in a fashion directly comparable to CCG and MCG (obviously, for the latter case, since the above MCG is a subsystem of the DC). For example, the combination x/y, y/z, z ::~ x has both left and right branching derivations.</Paragraph>
<Paragraph position="16"> However, a further equivalence problem arises due to the interderivability of types under the unary subsystem U. For any unary transformation x :=~ y, the converse y :~ x is always possible, and the semantics of these transformations are always inverses. (This obviously holds for a, and can be shown to hold for more complex transformations by a simple induction.) Consequently, if parsing assigns distinct types x and y to some substring that are merely variants under the unary calculus, this will engender redundancy, since anything that can be proven with x can equivalently be proven with y.</Paragraph>
<Paragraph position="18"> Normalisation and the Dependency Calculus These efficiency problems for parsing with the DC can be seen to result from equivalence amongst terms occurring at a number of levels within the system.</Paragraph>
<Paragraph position="19"> Our solution to this problem involves specifying normal forms (NFs) for terms -- to act as privileged members of their equivalence class -- at three different levels of the system: (i) types, (ii) binary combinations, (iii) proofs. The resulting system allows for efficient categorial parsing which is incremental up to the limit allowed by the DC.</Paragraph>
<Paragraph position="20"> A standard way of specifying NFs is based on the method of reduction, and involves defining a contraction relation (I&gt;1) between terms, which is stated as a number of contraction rules of the form X !&gt;1 Y (where X is termed a redez and Y its contractum). Each contraction rule allows that a term containing a redex may be transformed into a term where that occurrence is replaced by its contractum.</Paragraph>
<Paragraph position="21"> A term is said to be in NF if and only if it contains no redexes. The contraction relation generates a reduction relation (1&gt;) such that X reduces to Y (X I&gt; Y) iff Y is obtained from X by a finite series (possibly zero) of contractions. A term Y is a NF of X iff Y is a NF and X 1&gt; Y. The contraction relation also generates an equivalence relation which is such that X = Y iff Y can be obtained from X by a sequence of zero or more steps, each of which is either a contraction or reverse contraction.</Paragraph>
<Paragraph position="22"> Interderivability of types under U can be seen as giving a notion of equivalence for types. The contraction rule (17) defines a NF for types. Since contraction rules apply to any redex subformula occurring within some overall term, this rule's domain of application is as broad as that of the associativity axioms in the unary calculus given the generalising effects of the unary metarules. Hence, the notion of equivalence generated by rule (16) is the same as that defined by interderivability under U. It is straightforward to show that the reduction relation defined by (16) exhibits two important properties: (i) strong normalisation 1deg, with the 1degTo prove strong normalisation it is sufficient to give a metric which assigns each term a finite non-negative integer score, and under which every contraction reduces the score for a term by a positive integer amount. The following metric  suffices: (a) X ~ = 1 if X is atomic, (b) (X/Y) t = X ~ + Y~, (c) (X\Y)' = 2(X' + Y').</Paragraph>
<Paragraph position="23">  consequence that every type has a NF, and (ii) the Church-Rosser property, from which it follows that NFs are unique. In (18), a constructive notion of NF is specified. It is easily shown that this constructive definition identifies the same types to be NFs as the reduetive definition. 11 (17) x/y\,. ~1 x\z/y (18) x\yl.-Yi/Yi+l..Yn where n _~ 0, x is a basic type and each yj  (1 &lt; j &lt; n) is in turn of this general form.</Paragraph>
<Paragraph position="24"> (19) C/: x/ut,.u, + y =~ z ==~</Paragraph>
<Paragraph position="26"> We next consider normalisation for binary combinations. For this purpose, we require a modified version of the binary calculus, called W, having the rules {L(n),R,f,b}), where L(n) is a 'generalised' variant of the metarule L, shown in (19) (where the notation X/Ul..Un is schematic for a function seeking n forward directional arguments, e.g. so that for n = 3 we have x/ux..un = X/Ul/U~/Us). Note that the case L(0) is equivalent to L.</Paragraph>
<Paragraph position="27"> We will show that for every binary combination X + Y =~ Z under the DC, there is a corresponding combination X' + Y~ =* Z' under W, where X ~, Y' and Z' are the NFs of X, Y and Z. To demonstrate this, it is sufficient to show that for every combination under B, there is a corresponding W combination of the NFs of the types (i.e. since for binary combinations under the DC, of the form in (16), the types occurring at the top and bottom of any sequence of unary transformations will have the same NF).</Paragraph>
<Paragraph position="28"> The following contraction rules define a NF for combinations under B ~ (which includes the combinations of B as a subset -- provided that each use of L is relabelled as L(0)):  (20) IF w l&gt;t w' THEN a. f: w/y + y :=~ w 1&gt;1 f: w'/y + y =~ w' b. f: y/w + w ::~ y I&gt;t f: y/w' + w' =~ y c. b: y+w\y=~w E&gt;lb: y+w~\y=~w' d. b: w + y\w :=~ y !&gt;1 b: w' + ykw' :=~ y e. L(i)C/: x\w/ul..Ui + y =~ z\w I&gt;1 L(i)C/: xkw'/ul..u/ + y =~ zkw t f. Re: x + y/w =~ z/w t&gt;l Re: x + y/w' ::~ z/w'  laThis NF is based on an arbitrary bias in the restructuring of types, i.e. ordering backward directional arguments after forward directional arguments. The opposite bias (i.e. forward arguments after backward arguments) could as well  have been chosen.</Paragraph>
<Paragraph position="29"> (21) L(i)RC/: x\w/ul..ui + y/v =~ z/v\w t&gt;l RL(i)C/: x\w/ul..ui + y/v ::~ zkw/v (22) L(o)f: x/w\v + w ~ x\v \[:&gt;1 f: x\v/w + w =~ x\v (23) L(i)f: xkw/ul..Ui + ui =*&amp;quot; x/ul..ui-t\w t&gt;l f: x\w/ul..ul + ui ~ x\w/ul..u;_~ for i &gt; O.</Paragraph>
<Paragraph position="30"> (24) b: ~. + x/y\~, ~ x/y ~1 Rb: z + x\z/y =~ x/y (25) L(i)C/: X/V\W/Ul..U i + y ~ Z\W E&gt; 1  These rules also transform the types involved into their NFs. In the cases in (20), a contraction is made without affecting the identity of the particular rule used to combine the types. In (21-25), the transformations made on types requires that some change be made to the rule used to combine them. The rules (26) and (27) recursively define new contractions in terms of the basic ones.</Paragraph>
<Paragraph position="31"> This reduction system can be shown to exhibit strong normalisation, and it is straightforward to argue that each combination must have a unique NF. This definition of NF accords with the constructive definition (28). (Note that the notation R n represents a sequence of n Rs, which are to be bracketed right-associatively with the following rule, e.g. so that R~f = (R(Rf)), and that i takes the same value for each L(i) in the sequence L(i)&amp;quot;L) (28) C/:x+y~z where x, y, z are NF types, and C/ is (Rnf) or (RnL(i)mb), for n, m &gt; 0.</Paragraph>
<Paragraph position="32"> Each proof of some combination xl,..,xn =~ x0 under the DC can be seen to consist of a number of binary 'subtrees', each of the form (16). If we substitute each binary subtree with its NF combination in W, this gives a proof of Xlt,..,x~ ' =~ x0 t (where each xl ~ is the NF ofxi). Hence, for every DC proof, there is a corresponding proof of the combination of the NFs of the same types under B'.</Paragraph>
<Paragraph position="33"> Even if we consider only proofs involving NF combinations in W, we observe spurious ambiguity of the kind familiar from CCG and MCG. Again, we can deal with this problem by defining NFs for such  proofs. Since we are interested in incremental processing, our method for identifying NF proofs is based on favouring left-branching structures.</Paragraph>
<Paragraph position="34"> Let us consider the patterns of functional dependency that are possible amongst sequences of three types. These are shown in (29). 12 Of these cases, some (i.e. (a) and (f)) can only be derived with a left-branching proof under B' (or the DC), and others (i.e. (b) and (e)) can only be derived with a right-branching proof. Combinations of the patterns (c),(d) and (g) commonly allow both right and left-branching derivations (though not in all cases).</Paragraph>
<Paragraph position="36"> NF binary combinations of the pattern in (28) take the two more specific forms in (30) and (31).</Paragraph>
<Paragraph position="37"> Knowing this, we can easily sketch out the schematic form of the three element combinations corresponding to (29c,d,g) which have equivalent left and right branching proofs, as shown in Figure 1.</Paragraph>
<Paragraph position="38"> We can define a NF for proofs under B I (that use only NF combinations) by stating three contraction rules, one for each of the three cases in Figure 1, where each rule rewrites the right branching threeleaf subproof as the equivalent left branching subproof. This will identify the optimally left branching member of each equivalence class of proofs as its NF exemplar. Again, it is easily shown that reduction under these rules exhibits strong normalisation and the Church-Rosser property, so that every proof must have a unique normal form. However, it is not so easy to prove the stronger claim that there is only a single NF proof that assigns each distinct reading for any combination. 13 We shall not attempt 12Note that various other conceivable patterns of dependency do not need to be considered here since they do not correspond to any Lambek-valid combination.</Paragraph>
<Paragraph position="39"> ~3 Thls holds if the contraction relation generates an equivto demonstrate this property, although we believe that it holds. We can identify the redexes of these three contraction rules purely in terms of the rules used to combine types, i.e. without needing to examine the schematic form of the types, since the rules themselves identify the relevant structure of the types. In fact, the right-branching subproofs for cases (29c,g) collapse to the single schematic redex (32), and that for (29d) simplifies to the schematic redex (33). (Note that the notation C/~ is used to represent any (NF) rule which is recursively defined on a second rule ~r, e.g. so that ~rb is any NF rule  Let us consider the use of this system for parsing. In seeking combinations of some sequence of types, we first begin by transforming the types into their NFs. 14 Then, we can search for proofs using only the NF binary combinations. Any proof that is found to contain a proof redexes is discontinued, so that only NF proofs are returned, avoiding the problems of spurious ambiguity. Any result types assigned by such proofs stand as NF exemplars for the set of non-NF types that could be derived from the original input types under the DC. We may want to know if some input types can combine to give a specific result type x. This will be the case if the parser returns the NF of x.</Paragraph>
<Paragraph position="40"> Regarding incremental processing, we have seen that the DC is well-suited to this task in terms of allowing combinations that may usefully contribute to a knowledge of the semantic relations amongst the phrases combined, and that the NF proofs we have defined (and which the parser will construct) are optimally left-branching to the limit set by the calculus. Hence, in left-to-right analysis of sentences, the parser will be able to combine the presented material to the maximal extent that doing so usefully contributes to incremental interpretation and the filtering of semantically implausible analyses.</Paragraph>
<Paragraph position="41"> alence relation that equates any two proofs iff these assign extenslonally equivalent readings.</Paragraph>
<Paragraph position="42"> 14The complexity of this transformation is constant in the complexity of the type.</Paragraph>
</Section>
</Section>
</Paper>

